/* automatically generated by rust-bindgen 0.69.4 */

#![allow(dead_code,non_upper_case_globals,non_camel_case_types,non_snake_case)]

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const VMBINFINITE: u32 = 4294967295;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " \\brief 8-bit signed integer."]
pub type VmbInt8_t = ::std::os::raw::c_schar;
#[doc = " \\brief 8-bit unsigned integer."]
pub type VmbUint8_t = ::std::os::raw::c_uchar;
#[doc = " \\brief 16-bit signed integer."]
pub type VmbInt16_t = ::std::os::raw::c_short;
#[doc = " \\brief 16-bit unsigned integer."]
pub type VmbUint16_t = ::std::os::raw::c_ushort;
#[doc = " \\brief 32-bit signed integer."]
pub type VmbInt32_t = ::std::os::raw::c_int;
#[doc = " \\brief 32-bit unsigned integer."]
pub type VmbUint32_t = ::std::os::raw::c_uint;
#[doc = " \\brief 64-bit signed integer."]
pub type VmbInt64_t = ::std::os::raw::c_longlong;
#[doc = " \\brief 64-bit unsigned integer."]
pub type VmbUint64_t = ::std::os::raw::c_ulonglong;
#[doc = " \\brief Handle, e.g. for a camera."]
pub type VmbHandle_t = *mut ::std::os::raw::c_void;
#[doc = " \\brief Boolean type (equivalent to char).\n\n For values see ::VmbBoolVal"]
pub type VmbBool_t = ::std::os::raw::c_char;
pub mod VmbBoolVal {
    #[doc = " \\brief enum for bool values."]
    pub type Type = ::std::os::raw::c_uint;
    pub const VmbBoolTrue: Type = 1;
    pub const VmbBoolFalse: Type = 0;
}
#[doc = " \\brief char type."]
pub type VmbUchar_t = ::std::os::raw::c_uchar;
#[doc = " Character type used for file paths"]
pub type VmbFilePathChar_t = ::std::os::raw::c_char;
pub mod VmbErrorType {
    #[doc = " \\brief Error codes, returned by most functions."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "!< No error"]
    pub const VmbErrorSuccess: Type = 0;
    #[doc = "!< Unexpected fault in VmbC or driver"]
    pub const VmbErrorInternalFault: Type = -1;
    #[doc = "!< ::VmbStartup() was not called before the current command"]
    pub const VmbErrorApiNotStarted: Type = -2;
    #[doc = "!< The designated instance (camera, feature etc.) cannot be found"]
    pub const VmbErrorNotFound: Type = -3;
    #[doc = "!< The given handle is not valid"]
    pub const VmbErrorBadHandle: Type = -4;
    #[doc = "!< Device was not opened for usage"]
    pub const VmbErrorDeviceNotOpen: Type = -5;
    #[doc = "!< Operation is invalid with the current access mode"]
    pub const VmbErrorInvalidAccess: Type = -6;
    #[doc = "!< One of the parameters is invalid (usually an illegal pointer)"]
    pub const VmbErrorBadParameter: Type = -7;
    #[doc = "!< The given struct size is not valid for this version of the API"]
    pub const VmbErrorStructSize: Type = -8;
    #[doc = "!< More data available in a string/list than space is provided"]
    pub const VmbErrorMoreData: Type = -9;
    #[doc = "!< Wrong feature type for this access function"]
    pub const VmbErrorWrongType: Type = -10;
    #[doc = "!< The value is not valid; either out of bounds or not an increment of the minimum"]
    pub const VmbErrorInvalidValue: Type = -11;
    #[doc = "!< Timeout during wait"]
    pub const VmbErrorTimeout: Type = -12;
    #[doc = "!< Other error"]
    pub const VmbErrorOther: Type = -13;
    #[doc = "!< Resources not available (e.g. memory)"]
    pub const VmbErrorResources: Type = -14;
    #[doc = "!< Call is invalid in the current context (e.g. callback)"]
    pub const VmbErrorInvalidCall: Type = -15;
    #[doc = "!< No transport layers are found"]
    pub const VmbErrorNoTL: Type = -16;
    #[doc = "!< API feature is not implemented"]
    pub const VmbErrorNotImplemented: Type = -17;
    #[doc = "!< API feature is not supported"]
    pub const VmbErrorNotSupported: Type = -18;
    #[doc = "!< The current operation was not completed (e.g. a multiple registers read or write)"]
    pub const VmbErrorIncomplete: Type = -19;
    #[doc = "!< Low level IO error in transport layer"]
    pub const VmbErrorIO: Type = -20;
    #[doc = "!< The valid value set could not be retrieved, since the feature does not provide this property"]
    pub const VmbErrorValidValueSetNotPresent: Type = -21;
    #[doc = "!< Unspecified GenTL runtime error"]
    pub const VmbErrorGenTLUnspecified: Type = -22;
    #[doc = "!< Unspecified runtime error"]
    pub const VmbErrorUnspecified: Type = -23;
    #[doc = "!< The responsible module/entity is busy executing actions"]
    pub const VmbErrorBusy: Type = -24;
    #[doc = "!< The function has no data to work on"]
    pub const VmbErrorNoData: Type = -25;
    #[doc = "!< An error occurred parsing a buffer containing chunk data"]
    pub const VmbErrorParsingChunkData: Type = -26;
    #[doc = "!< Something is already in use"]
    pub const VmbErrorInUse: Type = -27;
    #[doc = "!< Error condition unknown"]
    pub const VmbErrorUnknown: Type = -28;
    #[doc = "!< Error parsing XML"]
    pub const VmbErrorXml: Type = -29;
    #[doc = "!< Something is not available"]
    pub const VmbErrorNotAvailable: Type = -30;
    #[doc = "!< Something is not initialized"]
    pub const VmbErrorNotInitialized: Type = -31;
    #[doc = "!< The given address is out of range or invalid for internal reasons"]
    pub const VmbErrorInvalidAddress: Type = -32;
    #[doc = "!< Something has already been done"]
    pub const VmbErrorAlready: Type = -33;
    #[doc = "!< A frame expected to contain chunk data does not contain chunk data"]
    pub const VmbErrorNoChunkData: Type = -34;
    #[doc = "!< A callback provided by the user threw an exception"]
    pub const VmbErrorUserCallbackException: Type = -35;
    #[doc = "!< The XML for the module is currently not loaded; the module could be in the wrong state or the XML could not be retrieved or could not be parsed properly"]
    pub const VmbErrorFeaturesUnavailable: Type = -36;
    #[doc = "!< A required transport layer could not be found or loaded"]
    pub const VmbErrorTLNotFound: Type = -37;
    #[doc = "!< An entity cannot be uniquely identified based on the information provided"]
    pub const VmbErrorAmbiguous: Type = -39;
    #[doc = "!< Something could not be accomplished with a given number of retries"]
    pub const VmbErrorRetriesExceeded: Type = -40;
    #[doc = "!< The operation requires more buffers"]
    pub const VmbErrorInsufficientBufferCount: Type = -41;
    #[doc = "!< The minimum error code to use for user defined error codes to avoid conflict with existing error codes"]
    pub const VmbErrorCustom: Type = 1;
}
#[doc = " \\brief Type for an error returned by API methods; for values see ::VmbErrorType."]
pub type VmbError_t = VmbInt32_t;
#[doc = " \\brief Version information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbVersionInfo {
    #[doc = "!< Major version number"]
    pub major: VmbUint32_t,
    #[doc = "!< Minor version number"]
    pub minor: VmbUint32_t,
    #[doc = "!< Patch version number"]
    pub patch: VmbUint32_t,
}
#[test]
fn bindgen_test_layout_VmbVersionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmbVersionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbVersionInfo>(),
        12usize,
        concat!("Size of: ", stringify!(VmbVersionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbVersionInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(VmbVersionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbVersionInfo),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbVersionInfo),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbVersionInfo),
            "::",
            stringify!(patch)
        )
    );
}
#[doc = " \\brief Version information."]
pub type VmbVersionInfo_t = VmbVersionInfo;
pub mod VmbPixelType {
    #[doc = " \\brief Indicates if pixel is monochrome or RGB."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Monochrome pixel"]
    pub const VmbPixelMono: Type = 16777216;
    #[doc = "!< Pixel bearing color information"]
    pub const VmbPixelColor: Type = 33554432;
}
pub mod VmbPixelOccupyType {
    #[doc = " \\brief Indicates number of bits for a pixel. Needed for building values of ::VmbPixelFormatType."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Pixel effectively occupies 8 bits"]
    pub const VmbPixelOccupy8Bit: Type = 524288;
    #[doc = "!< Pixel effectively occupies 10 bits"]
    pub const VmbPixelOccupy10Bit: Type = 655360;
    #[doc = "!< Pixel effectively occupies 12 bits"]
    pub const VmbPixelOccupy12Bit: Type = 786432;
    #[doc = "!< Pixel effectively occupies 14 bits"]
    pub const VmbPixelOccupy14Bit: Type = 917504;
    #[doc = "!< Pixel effectively occupies 16 bits"]
    pub const VmbPixelOccupy16Bit: Type = 1048576;
    #[doc = "!< Pixel effectively occupies 24 bits"]
    pub const VmbPixelOccupy24Bit: Type = 1572864;
    #[doc = "!< Pixel effectively occupies 32 bits"]
    pub const VmbPixelOccupy32Bit: Type = 2097152;
    #[doc = "!< Pixel effectively occupies 48 bits"]
    pub const VmbPixelOccupy48Bit: Type = 3145728;
    #[doc = "!< Pixel effectively occupies 64 bits"]
    pub const VmbPixelOccupy64Bit: Type = 4194304;
}
pub mod VmbPixelFormatType {
    #[doc = " \\brief Pixel format types.\n As far as possible, the Pixel Format Naming Convention (PFNC) has been followed, allowing a few deviations.\n If data spans more than one byte, it is always LSB aligned, except if stated differently."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Monochrome, 8 bits (PFNC:  Mono8)"]
    pub const VmbPixelFormatMono8: Type = 17301505;
    #[doc = "!< Monochrome, 10 bits in 16 bits (PFNC:  Mono10)"]
    pub const VmbPixelFormatMono10: Type = 17825795;
    #[doc = "!< Monochrome, 10 bits in 16 bits (PFNC:  Mono10p)"]
    pub const VmbPixelFormatMono10p: Type = 17432646;
    #[doc = "!< Monochrome, 12 bits in 16 bits (PFNC:  Mono12)"]
    pub const VmbPixelFormatMono12: Type = 17825797;
    #[doc = "!< Monochrome, 2x12 bits in 24 bits (GEV:Mono12Packed)"]
    pub const VmbPixelFormatMono12Packed: Type = 17563654;
    #[doc = "!< Monochrome, 2x12 bits in 24 bits (PFNC:  MonoPacked)"]
    pub const VmbPixelFormatMono12p: Type = 17563719;
    #[doc = "!< Monochrome, 14 bits in 16 bits (PFNC:  Mono14)"]
    pub const VmbPixelFormatMono14: Type = 17825829;
    #[doc = "!< Monochrome, 16 bits (PFNC:  Mono16)"]
    pub const VmbPixelFormatMono16: Type = 17825799;
    #[doc = "!< Bayer-color, 8 bits, starting with GR line (PFNC:  BayerGR8)"]
    pub const VmbPixelFormatBayerGR8: Type = 17301512;
    #[doc = "!< Bayer-color, 8 bits, starting with RG line (PFNC:  BayerRG8)"]
    pub const VmbPixelFormatBayerRG8: Type = 17301513;
    #[doc = "!< Bayer-color, 8 bits, starting with GB line (PFNC:  BayerGB8)"]
    pub const VmbPixelFormatBayerGB8: Type = 17301514;
    #[doc = "!< Bayer-color, 8 bits, starting with BG line (PFNC:  BayerBG8)"]
    pub const VmbPixelFormatBayerBG8: Type = 17301515;
    #[doc = "!< Bayer-color, 10 bits in 16 bits, starting with GR line (PFNC:  BayerGR10)"]
    pub const VmbPixelFormatBayerGR10: Type = 17825804;
    #[doc = "!< Bayer-color, 10 bits in 16 bits, starting with RG line (PFNC:  BayerRG10)"]
    pub const VmbPixelFormatBayerRG10: Type = 17825805;
    #[doc = "!< Bayer-color, 10 bits in 16 bits, starting with GB line (PFNC:  BayerGB10)"]
    pub const VmbPixelFormatBayerGB10: Type = 17825806;
    #[doc = "!< Bayer-color, 10 bits in 16 bits, starting with BG line (PFNC:  BayerBG10)"]
    pub const VmbPixelFormatBayerBG10: Type = 17825807;
    #[doc = "!< Bayer-color, 12 bits in 16 bits, starting with GR line (PFNC:  BayerGR12)"]
    pub const VmbPixelFormatBayerGR12: Type = 17825808;
    #[doc = "!< Bayer-color, 12 bits in 16 bits, starting with RG line (PFNC:  BayerRG12)"]
    pub const VmbPixelFormatBayerRG12: Type = 17825809;
    #[doc = "!< Bayer-color, 12 bits in 16 bits, starting with GB line (PFNC:  BayerGB12)"]
    pub const VmbPixelFormatBayerGB12: Type = 17825810;
    #[doc = "!< Bayer-color, 12 bits in 16 bits, starting with BG line (PFNC:  BayerBG12)"]
    pub const VmbPixelFormatBayerBG12: Type = 17825811;
    #[doc = "!< Bayer-color, 2x12 bits in 24 bits, starting with GR line (GEV:BayerGR12Packed)"]
    pub const VmbPixelFormatBayerGR12Packed: Type = 17563690;
    #[doc = "!< Bayer-color, 2x12 bits in 24 bits, starting with RG line (GEV:BayerRG12Packed)"]
    pub const VmbPixelFormatBayerRG12Packed: Type = 17563691;
    #[doc = "!< Bayer-color, 2x12 bits in 24 bits, starting with GB line (GEV:BayerGB12Packed)"]
    pub const VmbPixelFormatBayerGB12Packed: Type = 17563692;
    #[doc = "!< Bayer-color, 2x12 bits in 24 bits, starting with BG line (GEV:BayerBG12Packed)"]
    pub const VmbPixelFormatBayerBG12Packed: Type = 17563693;
    #[doc = "!< Bayer-color, 10 bits continuous packed, starting with GR line (PFNC:  BayerGR10p)"]
    pub const VmbPixelFormatBayerGR10p: Type = 17432662;
    #[doc = "!< Bayer-color, 10 bits continuous packed, starting with RG line (PFNC:  BayerRG10p)"]
    pub const VmbPixelFormatBayerRG10p: Type = 17432664;
    #[doc = "!< Bayer-color, 10 bits continuous packed, starting with GB line (PFNC:  BayerGB10p)"]
    pub const VmbPixelFormatBayerGB10p: Type = 17432660;
    #[doc = "!< Bayer-color, 10 bits continuous packed, starting with BG line (PFNC:  BayerBG10p)"]
    pub const VmbPixelFormatBayerBG10p: Type = 17432658;
    #[doc = "!< Bayer-color, 12 bits continuous packed, starting with GR line (PFNC:  BayerGR12p)"]
    pub const VmbPixelFormatBayerGR12p: Type = 17563735;
    #[doc = "!< Bayer-color, 12 bits continuous packed, starting with RG line (PFNC:  BayerRG12p)"]
    pub const VmbPixelFormatBayerRG12p: Type = 17563737;
    #[doc = "!< Bayer-color, 12 bits continuous packed, starting with GB line (PFNC:  BayerGB12p)"]
    pub const VmbPixelFormatBayerGB12p: Type = 17563733;
    #[doc = "!< Bayer-color, 12 bits continuous packed, starting with BG line (PFNC: BayerBG12p)"]
    pub const VmbPixelFormatBayerBG12p: Type = 17563731;
    #[doc = "!< Bayer-color, 16 bits, starting with GR line (PFNC: BayerGR16)"]
    pub const VmbPixelFormatBayerGR16: Type = 17825838;
    #[doc = "!< Bayer-color, 16 bits, starting with RG line (PFNC: BayerRG16)"]
    pub const VmbPixelFormatBayerRG16: Type = 17825839;
    #[doc = "!< Bayer-color, 16 bits, starting with GB line (PFNC: BayerGB16)"]
    pub const VmbPixelFormatBayerGB16: Type = 17825840;
    #[doc = "!< Bayer-color, 16 bits, starting with BG line (PFNC: BayerBG16)"]
    pub const VmbPixelFormatBayerBG16: Type = 17825841;
    #[doc = "!< RGB, 8 bits x 3 (PFNC: RGB8)"]
    pub const VmbPixelFormatRgb8: Type = 35127316;
    #[doc = "!< BGR, 8 bits x 3 (PFNC: BGR8)"]
    pub const VmbPixelFormatBgr8: Type = 35127317;
    #[doc = "!< RGB, 12 bits in 16 bits x 3 (PFNC: RGB12)"]
    pub const VmbPixelFormatRgb10: Type = 36700184;
    #[doc = "!< RGB, 12 bits in 16 bits x 3 (PFNC: RGB12)"]
    pub const VmbPixelFormatBgr10: Type = 36700185;
    #[doc = "!< RGB, 12 bits in 16 bits x 3 (PFNC: RGB12)"]
    pub const VmbPixelFormatRgb12: Type = 36700186;
    #[doc = "!< RGB, 12 bits in 16 bits x 3 (PFNC: RGB12)"]
    pub const VmbPixelFormatBgr12: Type = 36700187;
    #[doc = "!< RGB, 14 bits in 16 bits x 3 (PFNC: RGB12)"]
    pub const VmbPixelFormatRgb14: Type = 36700254;
    #[doc = "!< RGB, 14 bits in 16 bits x 3 (PFNC: RGB12)"]
    pub const VmbPixelFormatBgr14: Type = 36700234;
    #[doc = "!< RGB, 16 bits x 3 (PFNC: RGB16)"]
    pub const VmbPixelFormatRgb16: Type = 36700211;
    #[doc = "!< RGB, 16 bits x 3 (PFNC: RGB16)"]
    pub const VmbPixelFormatBgr16: Type = 36700235;
    #[doc = "!< ARGB, 8 bits x 4 (PFNC: RGBa8)"]
    pub const VmbPixelFormatArgb8: Type = 35651606;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatRgba8: Type = 35651606;
    #[doc = "!< BGRA, 8 bits x 4 (PFNC: BGRa8)"]
    pub const VmbPixelFormatBgra8: Type = 35651607;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatRgba10: Type = 37748831;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatBgra10: Type = 37748812;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatRgba12: Type = 37748833;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatBgra12: Type = 37748814;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatRgba14: Type = 37748835;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatBgra14: Type = 37748816;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatRgba16: Type = 37748836;
    #[doc = "!< RGBA, 8 bits x 4, legacy name"]
    pub const VmbPixelFormatBgra16: Type = 37748817;
    #[doc = "!< YUV 4:1:1 with 8 bits (PFNC: YUV411_8_UYYVYY, GEV:YUV411Packed)"]
    pub const VmbPixelFormatYuv411: Type = 34340894;
    #[doc = "!< YUV 4:2:2 with 8 bits (PFNC: YUV422_8_UYVY, GEV:YUV422Packed)"]
    pub const VmbPixelFormatYuv422: Type = 34603039;
    #[doc = "!< YUV 4:4:4 with 8 bits (PFNC: YUV8_UYV, GEV:YUV444Packed)"]
    pub const VmbPixelFormatYuv444: Type = 35127328;
    #[doc = "!< YUV 4:2:2 with 8 bits Channel order YUYV (PFNC: YUV422_8)"]
    pub const VmbPixelFormatYuv422_8: Type = 34603058;
    #[doc = "!< YCbCr 4:4:4 with 8 bits (PFNC: YCbCr8_CbYCr) - identical to VmbPixelFormatYuv444"]
    pub const VmbPixelFormatYCbCr8_CbYCr: Type = 35127354;
    #[doc = "!< YCbCr 4:2:2 8-bit YCbYCr (PFNC: YCbCr422_8)"]
    pub const VmbPixelFormatYCbCr422_8: Type = 34603067;
    #[doc = "!< YCbCr 4:1:1 with 8 bits (PFNC: YCbCr411_8_CbYYCrYY) - identical to VmbPixelFormatYuv411"]
    pub const VmbPixelFormatYCbCr411_8_CbYYCrYY: Type = 34340924;
    #[doc = "!< YCbCr601 4:4:4 8-bit CbYCrt (PFNC: YCbCr601_8_CbYCr)"]
    pub const VmbPixelFormatYCbCr601_8_CbYCr: Type = 35127357;
    #[doc = "!< YCbCr601 4:2:2 8-bit YCbYCr (PFNC: YCbCr601_422_8)"]
    pub const VmbPixelFormatYCbCr601_422_8: Type = 34603070;
    #[doc = "!< YCbCr601 4:1:1 8-bit CbYYCrYY (PFNC: YCbCr601_411_8_CbYYCrYY)"]
    pub const VmbPixelFormatYCbCr601_411_8_CbYYCrYY: Type = 34340927;
    #[doc = "!< YCbCr709 4:4:4 8-bit CbYCr (PFNC: YCbCr709_8_CbYCr)"]
    pub const VmbPixelFormatYCbCr709_8_CbYCr: Type = 35127360;
    #[doc = "!< YCbCr709 4:2:2 8-bit YCbYCr (PFNC: YCbCr709_422_8)"]
    pub const VmbPixelFormatYCbCr709_422_8: Type = 34603073;
    #[doc = "!< YCbCr709 4:1:1 8-bit CbYYCrYY (PFNC: YCbCr709_411_8_CbYYCrYY)"]
    pub const VmbPixelFormatYCbCr709_411_8_CbYYCrYY: Type = 34340930;
    #[doc = "!< YCbCr 4:2:2 with 8 bits (PFNC: YCbCr422_8_CbYCrY) - identical to VmbPixelFormatYuv422"]
    pub const VmbPixelFormatYCbCr422_8_CbYCrY: Type = 34603075;
    #[doc = "!< YCbCr601 4:2:2 8-bit CbYCrY (PFNC: YCbCr601_422_8_CbYCrY)"]
    pub const VmbPixelFormatYCbCr601_422_8_CbYCrY: Type = 34603076;
    #[doc = "!< YCbCr709 4:2:2 8-bit CbYCrY (PFNC: YCbCr709_422_8_CbYCrY)"]
    pub const VmbPixelFormatYCbCr709_422_8_CbYCrY: Type = 34603077;
    #[doc = "!< YCbCr 4:1:1 8-bit YYCbYYCr (PFNC: YCbCr411_8)"]
    pub const VmbPixelFormatYCbCr411_8: Type = 34340954;
    #[doc = "!< YCbCr 4:4:4 8-bit YCbCr (PFNC: YCbCr8)"]
    pub const VmbPixelFormatYCbCr8: Type = 35127387;
    pub const VmbPixelFormatLast: Type = 35127388;
}
#[doc = " \\brief Type for the pixel format; for values see ::VmbPixelFormatType."]
pub type VmbPixelFormat_t = VmbUint32_t;
pub mod VmbTransportLayerType {
    #[doc = " \\brief Camera or transport layer type (for instance U3V or GEV)."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Interface is not known to this version of the API"]
    pub const VmbTransportLayerTypeUnknown: Type = 0;
    #[doc = "!< GigE Vision"]
    pub const VmbTransportLayerTypeGEV: Type = 1;
    #[doc = "!< Camera Link"]
    pub const VmbTransportLayerTypeCL: Type = 2;
    #[doc = "!< IIDC 1394"]
    pub const VmbTransportLayerTypeIIDC: Type = 3;
    #[doc = "!< USB video class"]
    pub const VmbTransportLayerTypeUVC: Type = 4;
    #[doc = "!< CoaXPress"]
    pub const VmbTransportLayerTypeCXP: Type = 5;
    #[doc = "!< Camera Link HS"]
    pub const VmbTransportLayerTypeCLHS: Type = 6;
    #[doc = "!< USB3 Vision Standard"]
    pub const VmbTransportLayerTypeU3V: Type = 7;
    #[doc = "!< Generic Ethernet"]
    pub const VmbTransportLayerTypeEthernet: Type = 8;
    #[doc = "!< PCI / PCIe"]
    pub const VmbTransportLayerTypePCI: Type = 9;
    #[doc = "!< Non standard"]
    pub const VmbTransportLayerTypeCustom: Type = 10;
    #[doc = "!< Mixed (transport layer only)"]
    pub const VmbTransportLayerTypeMixed: Type = 11;
}
#[doc = " \\brief Type for an Interface; for values see ::VmbTransportLayerType."]
pub type VmbTransportLayerType_t = VmbUint32_t;
#[doc = " \\brief Transport layer information.\n\n Holds read-only information about a transport layer."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbTransportLayerInfo {
    #[doc = "!< Unique id of the transport layer"]
    pub transportLayerIdString: *const ::std::os::raw::c_char,
    #[doc = "!< Name of the transport layer"]
    pub transportLayerName: *const ::std::os::raw::c_char,
    #[doc = "!< Model name of the transport layer"]
    pub transportLayerModelName: *const ::std::os::raw::c_char,
    #[doc = "!< Vendor of the transport layer"]
    pub transportLayerVendor: *const ::std::os::raw::c_char,
    #[doc = "!< Version of the transport layer"]
    pub transportLayerVersion: *const ::std::os::raw::c_char,
    #[doc = "!< Full path of the transport layer"]
    pub transportLayerPath: *const ::std::os::raw::c_char,
    #[doc = "!< Handle of the transport layer for feature access"]
    pub transportLayerHandle: VmbHandle_t,
    #[doc = "!< The type of the transport layer"]
    pub transportLayerType: VmbTransportLayerType_t,
}
#[test]
fn bindgen_test_layout_VmbTransportLayerInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmbTransportLayerInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbTransportLayerInfo>(),
        64usize,
        concat!("Size of: ", stringify!(VmbTransportLayerInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbTransportLayerInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbTransportLayerInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerIdString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerIdString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerModelName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerModelName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerVendor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerVendor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerVersion) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerPath) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerHandle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerType) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbTransportLayerInfo),
            "::",
            stringify!(transportLayerType)
        )
    );
}
#[doc = " \\brief Transport layer information.\n\n Holds read-only information about a transport layer."]
pub type VmbTransportLayerInfo_t = VmbTransportLayerInfo;
#[doc = " \\brief Interface information.\n\n Holds read-only information about an interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbInterfaceInfo {
    #[doc = "!< Identifier of the interface"]
    pub interfaceIdString: *const ::std::os::raw::c_char,
    #[doc = "!< Interface name, given by the transport layer"]
    pub interfaceName: *const ::std::os::raw::c_char,
    #[doc = "!< Handle of the interface for feature access"]
    pub interfaceHandle: VmbHandle_t,
    #[doc = "!< Handle of the related transport layer for feature access"]
    pub transportLayerHandle: VmbHandle_t,
    #[doc = "!< The technology of the interface"]
    pub interfaceType: VmbTransportLayerType_t,
}
#[test]
fn bindgen_test_layout_VmbInterfaceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmbInterfaceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbInterfaceInfo>(),
        40usize,
        concat!("Size of: ", stringify!(VmbInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbInterfaceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaceIdString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbInterfaceInfo),
            "::",
            stringify!(interfaceIdString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaceName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbInterfaceInfo),
            "::",
            stringify!(interfaceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaceHandle) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbInterfaceInfo),
            "::",
            stringify!(interfaceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerHandle) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbInterfaceInfo),
            "::",
            stringify!(transportLayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaceType) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbInterfaceInfo),
            "::",
            stringify!(interfaceType)
        )
    );
}
#[doc = " \\brief Interface information.\n\n Holds read-only information about an interface."]
pub type VmbInterfaceInfo_t = VmbInterfaceInfo;
pub mod VmbAccessModeType {
    #[doc = " \\brief Access mode for cameras.\n\n Used in ::VmbCameraInfo_t as flags, so multiple modes can be\n announced, while in ::VmbCameraOpen(), no combination must be used."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< No access"]
    pub const VmbAccessModeNone: Type = 0;
    #[doc = "!< Read and write access"]
    pub const VmbAccessModeFull: Type = 1;
    #[doc = "!< Read-only access"]
    pub const VmbAccessModeRead: Type = 2;
    #[doc = "!< Access type unknown"]
    pub const VmbAccessModeUnknown: Type = 4;
    #[doc = "!< Read and write access without permitting access for other consumers"]
    pub const VmbAccessModeExclusive: Type = 8;
}
#[doc = " \\brief Type for an AccessMode; for values see ::VmbAccessModeType."]
pub type VmbAccessMode_t = VmbUint32_t;
#[doc = " \\brief Camera information.\n\n Holds read-only information about a camera."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbCameraInfo {
    #[doc = "!< Identifier of the camera"]
    pub cameraIdString: *const ::std::os::raw::c_char,
    #[doc = "!< globally unique identifier for the camera"]
    pub cameraIdExtended: *const ::std::os::raw::c_char,
    #[doc = "!< The display name of the camera"]
    pub cameraName: *const ::std::os::raw::c_char,
    #[doc = "!< Model name"]
    pub modelName: *const ::std::os::raw::c_char,
    #[doc = "!< Serial number"]
    pub serialString: *const ::std::os::raw::c_char,
    #[doc = "!< Handle of the related transport layer for feature access"]
    pub transportLayerHandle: VmbHandle_t,
    #[doc = "!< Handle of the related interface for feature access"]
    pub interfaceHandle: VmbHandle_t,
    #[doc = "!< Handle of the related GenTL local device. NULL if the camera is not opened"]
    pub localDeviceHandle: VmbHandle_t,
    #[doc = "!< Handles of the streams provided by the camera.  NULL if the camera is not opened"]
    pub streamHandles: *const VmbHandle_t,
    #[doc = "!< Number of stream handles in the streamHandles array"]
    pub streamCount: VmbUint32_t,
    #[doc = "!< Permitted access modes, see ::VmbAccessModeType"]
    pub permittedAccess: VmbAccessMode_t,
}
#[test]
fn bindgen_test_layout_VmbCameraInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmbCameraInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbCameraInfo>(),
        80usize,
        concat!("Size of: ", stringify!(VmbCameraInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbCameraInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbCameraInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cameraIdString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(cameraIdString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cameraIdExtended) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(cameraIdExtended)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cameraName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(cameraName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modelName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(modelName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialString) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(serialString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transportLayerHandle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(transportLayerHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaceHandle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(interfaceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localDeviceHandle) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(localDeviceHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamHandles) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(streamHandles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).streamCount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(streamCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).permittedAccess) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbCameraInfo),
            "::",
            stringify!(permittedAccess)
        )
    );
}
#[doc = " \\brief Camera information.\n\n Holds read-only information about a camera."]
pub type VmbCameraInfo_t = VmbCameraInfo;
pub mod VmbFeatureDataType {
    #[doc = " \\brief Supported feature data types."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Unknown feature type"]
    pub const VmbFeatureDataUnknown: Type = 0;
    #[doc = "!< 64-bit integer feature"]
    pub const VmbFeatureDataInt: Type = 1;
    #[doc = "!< 64-bit floating point feature"]
    pub const VmbFeatureDataFloat: Type = 2;
    #[doc = "!< Enumeration feature"]
    pub const VmbFeatureDataEnum: Type = 3;
    #[doc = "!< String feature"]
    pub const VmbFeatureDataString: Type = 4;
    #[doc = "!< Boolean feature"]
    pub const VmbFeatureDataBool: Type = 5;
    #[doc = "!< Command feature"]
    pub const VmbFeatureDataCommand: Type = 6;
    #[doc = "!< Raw (direct register access) feature"]
    pub const VmbFeatureDataRaw: Type = 7;
    #[doc = "!< Feature with no data"]
    pub const VmbFeatureDataNone: Type = 8;
}
#[doc = " \\brief Data type for a Feature; for values see ::VmbFeatureDataType."]
pub type VmbFeatureData_t = VmbUint32_t;
pub mod VmbFeatureVisibilityType {
    #[doc = " \\brief Feature visibility."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Feature visibility is not known"]
    pub const VmbFeatureVisibilityUnknown: Type = 0;
    #[doc = "!< Feature is visible in feature list (beginner level)"]
    pub const VmbFeatureVisibilityBeginner: Type = 1;
    #[doc = "!< Feature is visible in feature list (expert level)"]
    pub const VmbFeatureVisibilityExpert: Type = 2;
    #[doc = "!< Feature is visible in feature list (guru level)"]
    pub const VmbFeatureVisibilityGuru: Type = 3;
    #[doc = "!< Feature is visible in the feature list, but should be hidden in GUI applications"]
    pub const VmbFeatureVisibilityInvisible: Type = 4;
}
#[doc = " \\brief Type for Feature visibility; for values see ::VmbFeatureVisibilityType."]
pub type VmbFeatureVisibility_t = VmbUint32_t;
impl VmbFeatureFlagsType {
    #[doc = "!< No additional information is provided"]
    pub const VmbFeatureFlagsNone: VmbFeatureFlagsType = VmbFeatureFlagsType(0);
}
impl VmbFeatureFlagsType {
    #[doc = "!< Static info about read access. Current status depends on access mode, check with ::VmbFeatureAccessQuery()"]
    pub const VmbFeatureFlagsRead: VmbFeatureFlagsType = VmbFeatureFlagsType(1);
}
impl VmbFeatureFlagsType {
    #[doc = "!< Static info about write access. Current status depends on access mode, check with ::VmbFeatureAccessQuery()"]
    pub const VmbFeatureFlagsWrite: VmbFeatureFlagsType = VmbFeatureFlagsType(2);
}
impl VmbFeatureFlagsType {
    #[doc = "!< Value may change at any time"]
    pub const VmbFeatureFlagsVolatile: VmbFeatureFlagsType = VmbFeatureFlagsType(8);
}
impl VmbFeatureFlagsType {
    #[doc = "!< Value may change after a write"]
    pub const VmbFeatureFlagsModifyWrite: VmbFeatureFlagsType = VmbFeatureFlagsType(16);
}
impl ::std::ops::BitOr<VmbFeatureFlagsType> for VmbFeatureFlagsType {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VmbFeatureFlagsType(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VmbFeatureFlagsType {
    #[inline]
    fn bitor_assign(&mut self, rhs: VmbFeatureFlagsType) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VmbFeatureFlagsType> for VmbFeatureFlagsType {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VmbFeatureFlagsType(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VmbFeatureFlagsType {
    #[inline]
    fn bitand_assign(&mut self, rhs: VmbFeatureFlagsType) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief Feature flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VmbFeatureFlagsType(pub ::std::os::raw::c_uint);
#[doc = " \\brief Type for Feature flags; for values see ::VmbFeatureFlagsType."]
pub type VmbFeatureFlags_t = VmbUint32_t;
#[doc = " \\brief Feature information.\n\n Holds read-only information about a feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFeatureInfo {
    #[doc = "!< Name used in the API"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "!< Category this feature can be found in"]
    pub category: *const ::std::os::raw::c_char,
    #[doc = "!< Feature name to be used in GUIs"]
    pub displayName: *const ::std::os::raw::c_char,
    #[doc = "!< Short description, e.g. for a tooltip"]
    pub tooltip: *const ::std::os::raw::c_char,
    #[doc = "!< Longer description"]
    pub description: *const ::std::os::raw::c_char,
    #[doc = "!< Namespace this feature resides in"]
    pub sfncNamespace: *const ::std::os::raw::c_char,
    #[doc = "!< Measuring unit as given in the XML file"]
    pub unit: *const ::std::os::raw::c_char,
    #[doc = "!< Representation of a numeric feature"]
    pub representation: *const ::std::os::raw::c_char,
    #[doc = "!< Data type of this feature"]
    pub featureDataType: VmbFeatureData_t,
    #[doc = "!< Access flags for this feature"]
    pub featureFlags: VmbFeatureFlags_t,
    #[doc = "!< Predefined polling time for volatile features"]
    pub pollingTime: VmbUint32_t,
    #[doc = "!< GUI visibility"]
    pub visibility: VmbFeatureVisibility_t,
    #[doc = "!< Indicates if a feature can be stored to / loaded from a file"]
    pub isStreamable: VmbBool_t,
    #[doc = "!< Indicates if the feature selects other features"]
    pub hasSelectedFeatures: VmbBool_t,
}
#[test]
fn bindgen_test_layout_VmbFeatureInfo() {
    const UNINIT: ::std::mem::MaybeUninit<VmbFeatureInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbFeatureInfo>(),
        88usize,
        concat!("Size of: ", stringify!(VmbFeatureInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFeatureInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbFeatureInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).category) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(displayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tooltip) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(tooltip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sfncNamespace) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(sfncNamespace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).representation) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(representation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).featureDataType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(featureDataType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).featureFlags) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(featureFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollingTime) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(pollingTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visibility) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(visibility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isStreamable) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(isStreamable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasSelectedFeatures) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureInfo),
            "::",
            stringify!(hasSelectedFeatures)
        )
    );
}
#[doc = " \\brief Feature information.\n\n Holds read-only information about a feature."]
pub type VmbFeatureInfo_t = VmbFeatureInfo;
#[doc = " \\brief Info about possible entries of an enumeration feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFeatureEnumEntry {
    #[doc = "!< Name used in the API"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "!< Enumeration entry name to be used in GUIs"]
    pub displayName: *const ::std::os::raw::c_char,
    #[doc = "!< Short description, e.g. for a tooltip"]
    pub tooltip: *const ::std::os::raw::c_char,
    #[doc = "!< Longer description"]
    pub description: *const ::std::os::raw::c_char,
    #[doc = "!< Integer value of this enumeration entry"]
    pub intValue: VmbInt64_t,
    #[doc = "!< Namespace this feature resides in"]
    pub sfncNamespace: *const ::std::os::raw::c_char,
    #[doc = "!< GUI visibility"]
    pub visibility: VmbFeatureVisibility_t,
}
#[test]
fn bindgen_test_layout_VmbFeatureEnumEntry() {
    const UNINIT: ::std::mem::MaybeUninit<VmbFeatureEnumEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbFeatureEnumEntry>(),
        56usize,
        concat!("Size of: ", stringify!(VmbFeatureEnumEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFeatureEnumEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbFeatureEnumEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureEnumEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).displayName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureEnumEntry),
            "::",
            stringify!(displayName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tooltip) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureEnumEntry),
            "::",
            stringify!(tooltip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureEnumEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intValue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureEnumEntry),
            "::",
            stringify!(intValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sfncNamespace) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureEnumEntry),
            "::",
            stringify!(sfncNamespace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).visibility) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeatureEnumEntry),
            "::",
            stringify!(visibility)
        )
    );
}
#[doc = " \\brief Info about possible entries of an enumeration feature."]
pub type VmbFeatureEnumEntry_t = VmbFeatureEnumEntry;
pub mod VmbFrameStatusType {
    #[doc = " \\brief Status of a frame transfer."]
    pub type Type = ::std::os::raw::c_int;
    #[doc = "!< Frame has been completed without errors"]
    pub const VmbFrameStatusComplete: Type = 0;
    #[doc = "!< Frame could not be filled to the end"]
    pub const VmbFrameStatusIncomplete: Type = -1;
    #[doc = "!< Frame buffer was too small"]
    pub const VmbFrameStatusTooSmall: Type = -2;
    #[doc = "!< Frame buffer was invalid"]
    pub const VmbFrameStatusInvalid: Type = -3;
}
#[doc = " \\brief Type for the frame status; for values see ::VmbFrameStatusType."]
pub type VmbFrameStatus_t = VmbInt32_t;
impl VmbFrameFlagsType {
    #[doc = "!< No additional information is provided"]
    pub const VmbFrameFlagsNone: VmbFrameFlagsType = VmbFrameFlagsType(0);
}
impl VmbFrameFlagsType {
    #[doc = "!< VmbFrame_t::width and VmbFrame_t::height are provided"]
    pub const VmbFrameFlagsDimension: VmbFrameFlagsType = VmbFrameFlagsType(1);
}
impl VmbFrameFlagsType {
    #[doc = "!< VmbFrame_t::offsetX and VmbFrame_t::offsetY are provided (ROI)"]
    pub const VmbFrameFlagsOffset: VmbFrameFlagsType = VmbFrameFlagsType(2);
}
impl VmbFrameFlagsType {
    #[doc = "!< VmbFrame_t::frameID is provided"]
    pub const VmbFrameFlagsFrameID: VmbFrameFlagsType = VmbFrameFlagsType(4);
}
impl VmbFrameFlagsType {
    #[doc = "!< VmbFrame_t::timestamp is provided"]
    pub const VmbFrameFlagsTimestamp: VmbFrameFlagsType = VmbFrameFlagsType(8);
}
impl VmbFrameFlagsType {
    #[doc = "!< VmbFrame_t::imageData is provided"]
    pub const VmbFrameFlagsImageData: VmbFrameFlagsType = VmbFrameFlagsType(16);
}
impl VmbFrameFlagsType {
    #[doc = "!< VmbFrame_t::payloadType is provided"]
    pub const VmbFrameFlagsPayloadType: VmbFrameFlagsType = VmbFrameFlagsType(32);
}
impl VmbFrameFlagsType {
    #[doc = "!< VmbFrame_t::chunkDataPresent is set based on info provided by the transport layer"]
    pub const VmbFrameFlagsChunkDataPresent: VmbFrameFlagsType = VmbFrameFlagsType(64);
}
impl ::std::ops::BitOr<VmbFrameFlagsType> for VmbFrameFlagsType {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        VmbFrameFlagsType(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for VmbFrameFlagsType {
    #[inline]
    fn bitor_assign(&mut self, rhs: VmbFrameFlagsType) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<VmbFrameFlagsType> for VmbFrameFlagsType {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        VmbFrameFlagsType(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for VmbFrameFlagsType {
    #[inline]
    fn bitand_assign(&mut self, rhs: VmbFrameFlagsType) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = " \\brief Frame flags."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct VmbFrameFlagsType(pub ::std::os::raw::c_uint);
#[doc = " \\brief Type for Frame flags; for values see ::VmbFrameFlagsType."]
pub type VmbFrameFlags_t = VmbUint32_t;
pub mod VmbPayloadType {
    #[doc = " \\brief Frame payload type."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Unknown payload type"]
    pub const VmbPayloadTypeUnknown: Type = 0;
    #[doc = "!< image data"]
    pub const VmbPayloadTypeImage: Type = 1;
    #[doc = "!< raw data"]
    pub const VmbPayloadTypeRaw: Type = 2;
    #[doc = "!< file data"]
    pub const VmbPayloadTypeFile: Type = 3;
    #[doc = "!< JPEG data as described in the GigEVision 2.0 specification"]
    pub const VmbPayloadTypeJPEG: Type = 5;
    #[doc = "!< JPEG 2000 data as described in the GigEVision 2.0 specification"]
    pub const VmbPayloadTypJPEG2000: Type = 6;
    #[doc = "!< H.264 data as described in the GigEVision 2.0 specification"]
    pub const VmbPayloadTypeH264: Type = 7;
    #[doc = "!< Chunk data exclusively"]
    pub const VmbPayloadTypeChunkOnly: Type = 8;
    #[doc = "!< Device specific data format"]
    pub const VmbPayloadTypeDeviceSpecific: Type = 9;
    #[doc = "!< GenDC data"]
    pub const VmbPayloadTypeGenDC: Type = 11;
}
#[doc = " \\brief Type representing the payload type of a frame. For values see ::VmbPayloadType."]
pub type VmbPayloadType_t = VmbUint32_t;
#[doc = " \\brief Type used to represent a dimension value, e.g. the image height."]
pub type VmbImageDimension_t = VmbUint32_t;
#[doc = " \\brief Frame delivered by the camera."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFrame {
    #[doc = "!< Comprises image and potentially chunk data"]
    pub buffer: *mut ::std::os::raw::c_void,
    #[doc = "!< The size of the data buffer"]
    pub bufferSize: VmbUint32_t,
    #[doc = "!< 4 void pointers that can be employed by the user (e.g. for storing handles)"]
    pub context: [*mut ::std::os::raw::c_void; 4usize],
    #[doc = "!< The resulting status of the receive operation"]
    pub receiveStatus: VmbFrameStatus_t,
    #[doc = "!< Unique ID of this frame in this stream"]
    pub frameID: VmbUint64_t,
    #[doc = "!< The timestamp set by the camera"]
    pub timestamp: VmbUint64_t,
    #[doc = "!< The start of the image data, if present, or null"]
    pub imageData: *mut VmbUint8_t,
    #[doc = "!< Flags indicating which additional frame information is available"]
    pub receiveFlags: VmbFrameFlags_t,
    #[doc = "!< Pixel format of the image"]
    pub pixelFormat: VmbPixelFormat_t,
    #[doc = "!< Width of an image"]
    pub width: VmbImageDimension_t,
    #[doc = "!< Height of an image"]
    pub height: VmbImageDimension_t,
    #[doc = "!< Horizontal offset of an image"]
    pub offsetX: VmbImageDimension_t,
    #[doc = "!< Vertical offset of an image"]
    pub offsetY: VmbImageDimension_t,
    #[doc = "!< The type of payload"]
    pub payloadType: VmbPayloadType_t,
    #[doc = "!< True if the transport layer reported chunk data to be present in the buffer"]
    pub chunkDataPresent: VmbBool_t,
}
#[test]
fn bindgen_test_layout_VmbFrame() {
    const UNINIT: ::std::mem::MaybeUninit<VmbFrame> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbFrame>(),
        112usize,
        concat!("Size of: ", stringify!(VmbFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(VmbFrame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(bufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiveStatus) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(receiveStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameID) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(frameID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imageData) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(imageData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiveFlags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(receiveFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixelFormat) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(pixelFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetX) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(offsetX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offsetY) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(offsetY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payloadType) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(payloadType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunkDataPresent) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFrame),
            "::",
            stringify!(chunkDataPresent)
        )
    );
}
#[doc = " \\brief Frame delivered by the camera."]
pub type VmbFrame_t = VmbFrame;
pub mod VmbFeaturePersistType {
    #[doc = " \\brief Type of features that are to be saved (persisted) to the XML file when using ::VmbSettingsSave"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Save all features to XML, including look-up tables (if possible)"]
    pub const VmbFeaturePersistAll: Type = 0;
    #[doc = "!< Save only features marked as streamable, excluding look-up tables"]
    pub const VmbFeaturePersistStreamable: Type = 1;
    #[doc = "!< Save all features except look-up tables (default)"]
    pub const VmbFeaturePersistNoLUT: Type = 2;
}
#[doc = " \\brief Type for feature persistence; for values see ::VmbFeaturePersistType."]
pub type VmbFeaturePersist_t = VmbUint32_t;
pub mod VmbModulePersistFlagsType {
    #[doc = " \\brief Parameters determining the operation mode of ::VmbSettingsSave and ::VmbSettingsLoad."]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Persist/Load features for no module."]
    pub const VmbModulePersistFlagsNone: Type = 0;
    #[doc = "!< Persist/Load the transport layer features."]
    pub const VmbModulePersistFlagsTransportLayer: Type = 1;
    #[doc = "!< Persist/Load the interface features."]
    pub const VmbModulePersistFlagsInterface: Type = 2;
    #[doc = "!< Persist/Load the remote device features."]
    pub const VmbModulePersistFlagsRemoteDevice: Type = 4;
    #[doc = "!< Persist/Load the local device features."]
    pub const VmbModulePersistFlagsLocalDevice: Type = 8;
    #[doc = "!< Persist/Load the features of stream modules."]
    pub const VmbModulePersistFlagsStreams: Type = 16;
    #[doc = "!< Persist/Load features for all modules."]
    pub const VmbModulePersistFlagsAll: Type = 255;
}
#[doc = " \\brief Type for module persist flags; for values see VmbModulePersistFlagsType\n\n Use a combination of ::VmbModulePersistFlagsType constants"]
pub type VmbModulePersistFlags_t = VmbUint32_t;
pub mod VmbLogLevel {
    #[doc = " \\brief A level to use for logging"]
    pub type Type = ::std::os::raw::c_uint;
    #[doc = "!< Nothing is logged regardless of the severity of the issue"]
    pub const VmbLogLevelNone: Type = 0;
    #[doc = "!< Only errors are logged"]
    pub const VmbLogLevelError: Type = 1;
    #[doc = "!< Only error and debug messages are logged"]
    pub const VmbLogLevelDebug: Type = 2;
    #[doc = "!< Only error, debug and warn messages are logged"]
    pub const VmbLogLevelWarn: Type = 3;
    #[doc = "!< all messages are logged"]
    pub const VmbLogLevelTrace: Type = 4;
    #[doc = "!< all messages are logged"]
    pub const VmbLogLevelAll: Type = 4;
}
#[doc = " \\brief The type used for storing the log level\n\n Use a constant from ::VmbLogLevel"]
pub type VmbLogLevel_t = VmbUint32_t;
#[doc = " \\brief Parameters determining the operation mode of ::VmbSettingsSave and ::VmbSettingsLoad"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct VmbFeaturePersistSettings {
    #[doc = "!< Type of features that are to be saved"]
    pub persistType: VmbFeaturePersist_t,
    #[doc = "!< Flags specifying the modules to persist/load"]
    pub modulePersistFlags: VmbModulePersistFlags_t,
    #[doc = "!< Number of iterations when loading settings"]
    pub maxIterations: VmbUint32_t,
    #[doc = "!< Determines level of detail for load/save settings logging"]
    pub loggingLevel: VmbLogLevel_t,
}
#[test]
fn bindgen_test_layout_VmbFeaturePersistSettings() {
    const UNINIT: ::std::mem::MaybeUninit<VmbFeaturePersistSettings> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<VmbFeaturePersistSettings>(),
        16usize,
        concat!("Size of: ", stringify!(VmbFeaturePersistSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<VmbFeaturePersistSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(VmbFeaturePersistSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).persistType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeaturePersistSettings),
            "::",
            stringify!(persistType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modulePersistFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeaturePersistSettings),
            "::",
            stringify!(modulePersistFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxIterations) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeaturePersistSettings),
            "::",
            stringify!(maxIterations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loggingLevel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VmbFeaturePersistSettings),
            "::",
            stringify!(loggingLevel)
        )
    );
}
#[doc = " \\brief Parameters determining the operation mode of ::VmbSettingsSave and ::VmbSettingsLoad"]
pub type VmbFeaturePersistSettings_t = VmbFeaturePersistSettings;
#[doc = " \\brief Invalidation callback type for a function that gets called in a separate thread\n        and has been registered with ::VmbFeatureInvalidationRegister().\n\n While the callback is run, all feature data is atomic. After the callback finishes,\n the feature data may be updated with new values.\n\n Do not spend too much time in this thread; it prevents the feature values\n from being updated from any other thread or the lower-level drivers.\n\n \\param[in]   handle              Handle for an entity that exposes features\n \\param[in]   name                Name of the feature\n \\param[in]   userContext         Pointer to the user context, see ::VmbFeatureInvalidationRegister"]
pub type VmbInvalidationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        userContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " \\brief Frame Callback type for a function that gets called in a separate thread\n        if a frame has been queued with ::VmbCaptureFrameQueue.\n\n \\warning Any operations closing the stream including ::VmbShutdown and ::VmbCameraClose in addition to\n          ::VmbCaptureEnd block until any currently active callbacks return. If the callback does not\n          return in finite time, the program may not return.\n\n \\param[in]   cameraHandle      Handle of the camera the frame belongs to\n \\param[in]   streamHandle      Handle of the stream the frame belongs to\n \\param[in]   frame             The received frame"]
pub type VmbFrameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        cameraHandle: VmbHandle_t,
        streamHandle: VmbHandle_t,
        frame: *mut VmbFrame_t,
    ),
>;
#[doc = " \\brief Function pointer type to access chunk data\n\n This function should complete as quickly as possible, since it blocks other updates on the\n remote device.\n\n This function should not throw exceptions, even if VmbC is used from C++. Any exception\n thrown will only result in an error code indicating that an exception was thrown.\n\n \\param[in] featureAccessHandle A special handle that can be used for accessing features;\n                                the handle is only valid during the call of the function.\n \\param[in] userContext         The value the user passed to ::VmbChunkDataAccess.\n\n \\return An error to be returned from ::VmbChunkDataAccess in the absence of other errors;\n         A custom exit code >= ::VmbErrorCustom can be returned to indicate a failure via\n         ::VmbChunkDataAccess return code"]
pub type VmbChunkAccessCallback = ::std::option::Option<
    unsafe extern "C" fn(
        featureAccessHandle: VmbHandle_t,
        userContext: *mut ::std::os::raw::c_void,
    ) -> VmbError_t,
>;
extern "C" {
    #[doc = " \\brief Constant for the Vmb handle to be able to access Vmb system features."]
    pub static gVmbHandle: VmbHandle_t;
}
extern crate libloading;
pub struct VimbaC {
    __library: ::libloading::Library,
    pub VmbVersionQuery: Result<
        unsafe extern "C" fn(
            versionInfo: *mut VmbVersionInfo_t,
            sizeofVersionInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbStartup: Result<
        unsafe extern "C" fn(pathConfiguration: *const VmbFilePathChar_t) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbShutdown: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub VmbCamerasList: Result<
        unsafe extern "C" fn(
            cameraInfo: *mut VmbCameraInfo_t,
            listLength: VmbUint32_t,
            numFound: *mut VmbUint32_t,
            sizeofCameraInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraInfoQueryByHandle: Result<
        unsafe extern "C" fn(
            cameraHandle: VmbHandle_t,
            info: *mut VmbCameraInfo_t,
            sizeofCameraInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraInfoQuery: Result<
        unsafe extern "C" fn(
            idString: *const ::std::os::raw::c_char,
            info: *mut VmbCameraInfo_t,
            sizeofCameraInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraOpen: Result<
        unsafe extern "C" fn(
            idString: *const ::std::os::raw::c_char,
            accessMode: VmbAccessMode_t,
            cameraHandle: *mut VmbHandle_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCameraClose:
        Result<unsafe extern "C" fn(cameraHandle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbFeaturesList: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            featureInfoList: *mut VmbFeatureInfo_t,
            listLength: VmbUint32_t,
            numFound: *mut VmbUint32_t,
            sizeofFeatureInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureInfoQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            featureInfo: *mut VmbFeatureInfo_t,
            sizeofFeatureInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureListSelected: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            featureInfoList: *mut VmbFeatureInfo_t,
            listLength: VmbUint32_t,
            numFound: *mut VmbUint32_t,
            sizeofFeatureInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureAccessQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            isReadable: *mut VmbBool_t,
            isWriteable: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntRangeQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            min: *mut VmbInt64_t,
            max: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntIncrementQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureIntValidValueSetQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            buffer: *mut VmbInt64_t,
            bufferSize: VmbUint32_t,
            setSize: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *mut f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatRangeQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            min: *mut f64,
            max: *mut f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureFloatIncrementQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            hasIncrement: *mut VmbBool_t,
            value: *mut f64,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *mut *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumRangeQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            nameArray: *mut *const ::std::os::raw::c_char,
            arrayLength: VmbUint32_t,
            numFound: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumIsAvailable: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
            isAvailable: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumAsInt: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
            intVal: *mut VmbInt64_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumAsString: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            intValue: VmbInt64_t,
            stringValue: *mut *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureEnumEntryGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            featureName: *const ::std::os::raw::c_char,
            entryName: *const ::std::os::raw::c_char,
            featureEnumEntry: *mut VmbFeatureEnumEntry_t,
            sizeofFeatureEnumEntry: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureStringGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            buffer: *mut ::std::os::raw::c_char,
            bufferSize: VmbUint32_t,
            sizeFilled: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureStringSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureStringMaxlengthQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            maxLength: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureBoolGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureBoolSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            value: VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureCommandRun: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureCommandIsDone: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            isDone: *mut VmbBool_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureRawGet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            buffer: *mut ::std::os::raw::c_char,
            bufferSize: VmbUint32_t,
            sizeFilled: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureRawSet: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            buffer: *const ::std::os::raw::c_char,
            bufferSize: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureRawLengthQuery: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            length: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureInvalidationRegister: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            callback: VmbInvalidationCallback,
            userContext: *mut ::std::os::raw::c_void,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFeatureInvalidationUnregister: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            name: *const ::std::os::raw::c_char,
            callback: VmbInvalidationCallback,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbPayloadSizeGet: Result<
        unsafe extern "C" fn(handle: VmbHandle_t, payloadSize: *mut VmbUint32_t) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFrameAnnounce: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            frame: *const VmbFrame_t,
            sizeofFrame: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFrameRevoke: Result<
        unsafe extern "C" fn(handle: VmbHandle_t, frame: *const VmbFrame_t) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbFrameRevokeAll:
        Result<unsafe extern "C" fn(handle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbCaptureStart:
        Result<unsafe extern "C" fn(handle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbCaptureEnd:
        Result<unsafe extern "C" fn(handle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbCaptureFrameQueue: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            frame: *const VmbFrame_t,
            callback: VmbFrameCallback,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCaptureFrameWait: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            frame: *const VmbFrame_t,
            timeout: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbCaptureQueueFlush:
        Result<unsafe extern "C" fn(handle: VmbHandle_t) -> VmbError_t, ::libloading::Error>,
    pub VmbTransportLayersList: Result<
        unsafe extern "C" fn(
            transportLayerInfo: *mut VmbTransportLayerInfo_t,
            listLength: VmbUint32_t,
            numFound: *mut VmbUint32_t,
            sizeofTransportLayerInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbInterfacesList: Result<
        unsafe extern "C" fn(
            interfaceInfo: *mut VmbInterfaceInfo_t,
            listLength: VmbUint32_t,
            numFound: *mut VmbUint32_t,
            sizeofInterfaceInfo: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbMemoryRead: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            address: VmbUint64_t,
            bufferSize: VmbUint32_t,
            dataBuffer: *mut ::std::os::raw::c_char,
            sizeComplete: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbMemoryWrite: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            address: VmbUint64_t,
            bufferSize: VmbUint32_t,
            dataBuffer: *const ::std::os::raw::c_char,
            sizeComplete: *mut VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbSettingsSave: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            filePath: *const VmbFilePathChar_t,
            settings: *const VmbFeaturePersistSettings_t,
            sizeofSettings: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbSettingsLoad: Result<
        unsafe extern "C" fn(
            handle: VmbHandle_t,
            filePath: *const VmbFilePathChar_t,
            settings: *const VmbFeaturePersistSettings_t,
            sizeofSettings: VmbUint32_t,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
    pub VmbChunkDataAccess: Result<
        unsafe extern "C" fn(
            frame: *const VmbFrame_t,
            chunkAccessCallback: VmbChunkAccessCallback,
            userContext: *mut ::std::os::raw::c_void,
        ) -> VmbError_t,
        ::libloading::Error,
    >,
}
impl VimbaC {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let VmbVersionQuery = __library.get(b"VmbVersionQuery\0").map(|sym| *sym);
        let VmbStartup = __library.get(b"VmbStartup\0").map(|sym| *sym);
        let VmbShutdown = __library.get(b"VmbShutdown\0").map(|sym| *sym);
        let VmbCamerasList = __library.get(b"VmbCamerasList\0").map(|sym| *sym);
        let VmbCameraInfoQueryByHandle = __library
            .get(b"VmbCameraInfoQueryByHandle\0")
            .map(|sym| *sym);
        let VmbCameraInfoQuery = __library.get(b"VmbCameraInfoQuery\0").map(|sym| *sym);
        let VmbCameraOpen = __library.get(b"VmbCameraOpen\0").map(|sym| *sym);
        let VmbCameraClose = __library.get(b"VmbCameraClose\0").map(|sym| *sym);
        let VmbFeaturesList = __library.get(b"VmbFeaturesList\0").map(|sym| *sym);
        let VmbFeatureInfoQuery = __library.get(b"VmbFeatureInfoQuery\0").map(|sym| *sym);
        let VmbFeatureListSelected = __library.get(b"VmbFeatureListSelected\0").map(|sym| *sym);
        let VmbFeatureAccessQuery = __library.get(b"VmbFeatureAccessQuery\0").map(|sym| *sym);
        let VmbFeatureIntGet = __library.get(b"VmbFeatureIntGet\0").map(|sym| *sym);
        let VmbFeatureIntSet = __library.get(b"VmbFeatureIntSet\0").map(|sym| *sym);
        let VmbFeatureIntRangeQuery = __library.get(b"VmbFeatureIntRangeQuery\0").map(|sym| *sym);
        let VmbFeatureIntIncrementQuery = __library
            .get(b"VmbFeatureIntIncrementQuery\0")
            .map(|sym| *sym);
        let VmbFeatureIntValidValueSetQuery = __library
            .get(b"VmbFeatureIntValidValueSetQuery\0")
            .map(|sym| *sym);
        let VmbFeatureFloatGet = __library.get(b"VmbFeatureFloatGet\0").map(|sym| *sym);
        let VmbFeatureFloatSet = __library.get(b"VmbFeatureFloatSet\0").map(|sym| *sym);
        let VmbFeatureFloatRangeQuery = __library
            .get(b"VmbFeatureFloatRangeQuery\0")
            .map(|sym| *sym);
        let VmbFeatureFloatIncrementQuery = __library
            .get(b"VmbFeatureFloatIncrementQuery\0")
            .map(|sym| *sym);
        let VmbFeatureEnumGet = __library.get(b"VmbFeatureEnumGet\0").map(|sym| *sym);
        let VmbFeatureEnumSet = __library.get(b"VmbFeatureEnumSet\0").map(|sym| *sym);
        let VmbFeatureEnumRangeQuery = __library.get(b"VmbFeatureEnumRangeQuery\0").map(|sym| *sym);
        let VmbFeatureEnumIsAvailable = __library
            .get(b"VmbFeatureEnumIsAvailable\0")
            .map(|sym| *sym);
        let VmbFeatureEnumAsInt = __library.get(b"VmbFeatureEnumAsInt\0").map(|sym| *sym);
        let VmbFeatureEnumAsString = __library.get(b"VmbFeatureEnumAsString\0").map(|sym| *sym);
        let VmbFeatureEnumEntryGet = __library.get(b"VmbFeatureEnumEntryGet\0").map(|sym| *sym);
        let VmbFeatureStringGet = __library.get(b"VmbFeatureStringGet\0").map(|sym| *sym);
        let VmbFeatureStringSet = __library.get(b"VmbFeatureStringSet\0").map(|sym| *sym);
        let VmbFeatureStringMaxlengthQuery = __library
            .get(b"VmbFeatureStringMaxlengthQuery\0")
            .map(|sym| *sym);
        let VmbFeatureBoolGet = __library.get(b"VmbFeatureBoolGet\0").map(|sym| *sym);
        let VmbFeatureBoolSet = __library.get(b"VmbFeatureBoolSet\0").map(|sym| *sym);
        let VmbFeatureCommandRun = __library.get(b"VmbFeatureCommandRun\0").map(|sym| *sym);
        let VmbFeatureCommandIsDone = __library.get(b"VmbFeatureCommandIsDone\0").map(|sym| *sym);
        let VmbFeatureRawGet = __library.get(b"VmbFeatureRawGet\0").map(|sym| *sym);
        let VmbFeatureRawSet = __library.get(b"VmbFeatureRawSet\0").map(|sym| *sym);
        let VmbFeatureRawLengthQuery = __library.get(b"VmbFeatureRawLengthQuery\0").map(|sym| *sym);
        let VmbFeatureInvalidationRegister = __library
            .get(b"VmbFeatureInvalidationRegister\0")
            .map(|sym| *sym);
        let VmbFeatureInvalidationUnregister = __library
            .get(b"VmbFeatureInvalidationUnregister\0")
            .map(|sym| *sym);
        let VmbPayloadSizeGet = __library.get(b"VmbPayloadSizeGet\0").map(|sym| *sym);
        let VmbFrameAnnounce = __library.get(b"VmbFrameAnnounce\0").map(|sym| *sym);
        let VmbFrameRevoke = __library.get(b"VmbFrameRevoke\0").map(|sym| *sym);
        let VmbFrameRevokeAll = __library.get(b"VmbFrameRevokeAll\0").map(|sym| *sym);
        let VmbCaptureStart = __library.get(b"VmbCaptureStart\0").map(|sym| *sym);
        let VmbCaptureEnd = __library.get(b"VmbCaptureEnd\0").map(|sym| *sym);
        let VmbCaptureFrameQueue = __library.get(b"VmbCaptureFrameQueue\0").map(|sym| *sym);
        let VmbCaptureFrameWait = __library.get(b"VmbCaptureFrameWait\0").map(|sym| *sym);
        let VmbCaptureQueueFlush = __library.get(b"VmbCaptureQueueFlush\0").map(|sym| *sym);
        let VmbTransportLayersList = __library.get(b"VmbTransportLayersList\0").map(|sym| *sym);
        let VmbInterfacesList = __library.get(b"VmbInterfacesList\0").map(|sym| *sym);
        let VmbMemoryRead = __library.get(b"VmbMemoryRead\0").map(|sym| *sym);
        let VmbMemoryWrite = __library.get(b"VmbMemoryWrite\0").map(|sym| *sym);
        let VmbSettingsSave = __library.get(b"VmbSettingsSave\0").map(|sym| *sym);
        let VmbSettingsLoad = __library.get(b"VmbSettingsLoad\0").map(|sym| *sym);
        let VmbChunkDataAccess = __library.get(b"VmbChunkDataAccess\0").map(|sym| *sym);
        Ok(VimbaC {
            __library,
            VmbVersionQuery,
            VmbStartup,
            VmbShutdown,
            VmbCamerasList,
            VmbCameraInfoQueryByHandle,
            VmbCameraInfoQuery,
            VmbCameraOpen,
            VmbCameraClose,
            VmbFeaturesList,
            VmbFeatureInfoQuery,
            VmbFeatureListSelected,
            VmbFeatureAccessQuery,
            VmbFeatureIntGet,
            VmbFeatureIntSet,
            VmbFeatureIntRangeQuery,
            VmbFeatureIntIncrementQuery,
            VmbFeatureIntValidValueSetQuery,
            VmbFeatureFloatGet,
            VmbFeatureFloatSet,
            VmbFeatureFloatRangeQuery,
            VmbFeatureFloatIncrementQuery,
            VmbFeatureEnumGet,
            VmbFeatureEnumSet,
            VmbFeatureEnumRangeQuery,
            VmbFeatureEnumIsAvailable,
            VmbFeatureEnumAsInt,
            VmbFeatureEnumAsString,
            VmbFeatureEnumEntryGet,
            VmbFeatureStringGet,
            VmbFeatureStringSet,
            VmbFeatureStringMaxlengthQuery,
            VmbFeatureBoolGet,
            VmbFeatureBoolSet,
            VmbFeatureCommandRun,
            VmbFeatureCommandIsDone,
            VmbFeatureRawGet,
            VmbFeatureRawSet,
            VmbFeatureRawLengthQuery,
            VmbFeatureInvalidationRegister,
            VmbFeatureInvalidationUnregister,
            VmbPayloadSizeGet,
            VmbFrameAnnounce,
            VmbFrameRevoke,
            VmbFrameRevokeAll,
            VmbCaptureStart,
            VmbCaptureEnd,
            VmbCaptureFrameQueue,
            VmbCaptureFrameWait,
            VmbCaptureQueueFlush,
            VmbTransportLayersList,
            VmbInterfacesList,
            VmbMemoryRead,
            VmbMemoryWrite,
            VmbSettingsSave,
            VmbSettingsLoad,
            VmbChunkDataAccess,
        })
    }
    #[doc = " \\brief Retrieve the version number of VmbC.\n\n This function can be called at anytime, even before the API is\n initialized. All other version numbers may be queried via feature access.\n\n \\param[out]  versionInfo             Pointer to the struct where version information resides\n \\param[in]   sizeofVersionInfo       Size of structure in bytes\n\n\n \\return An error code indicating success or the type of error.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback.\n\n \\retval ::VmbErrorStructSize         The given struct size is not valid for this version of the API\n\n \\retval ::VmbErrorBadParameter       \\p versionInfo is null.\n"]
    pub unsafe fn VmbVersionQuery(
        &self,
        versionInfo: *mut VmbVersionInfo_t,
        sizeofVersionInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbVersionQuery
            .as_ref()
            .expect("Expected function, got error."))(versionInfo, sizeofVersionInfo)
    }
    #[doc = " \\brief Initializes the VmbC API.\n\n Note: This function must be called before any VmbC function other than ::VmbVersionQuery() is run.\n\n \\param[in]   pathConfiguration       A string containing a semicolon (Windows) or colon (other os) separated list of paths. The paths contain directories to search for .cti files,\n                                      paths to .cti files and optionally the path to a configuration xml file. If null is passed the parameter is the cti files found in the paths\n                                      the GENICAM_GENTL{32|64}_PATH environment variable are considered\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorAlready            This function was called before and call to ::VmbShutdown has been executed on a non-callback thread\n\n \\retval ::VmbErrorInvalidCall        If called from a callback or ::VmbShutdown is currently running\n\n \\retval ::VmbErrorXml                If parsing the settings xml is unsuccessful; a missing default xml file does not result in this error.\n\n \\retval ::VmbErrorTLNotFound         A transport layer that was marked as required was not found.\n\n \\retval ::VmbErrorNoTL               No transport layer was found on the system; note that some of the transport layers may have been filtered out via the settings file.\n\n \\retval ::VmbErrorIO                 A log file should be written according to the settings xml file, but this log file could not be opened.\n\n \\retval ::VmbErrorBadParameter       \\p pathConfiguration contains only separator and whitespace chars.\n"]
    pub unsafe fn VmbStartup(&self, pathConfiguration: *const VmbFilePathChar_t) -> VmbError_t {
        (self
            .VmbStartup
            .as_ref()
            .expect("Expected function, got error."))(pathConfiguration)
    }
    #[doc = " \\brief Perform a shutdown of the API.\n\n This frees some resources and deallocates all physical resources if applicable.\n\n The call is silently ignored, if executed from a callback.\n"]
    pub unsafe fn VmbShutdown(&self) {
        (self
            .VmbShutdown
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " List all the cameras that are currently visible to the API.\n\n Note: This function is usually called twice: once with an empty array to query the length\n       of the list, and then again with an array of the correct length.\n       If camera lists change between the calls, numFound may deviate from the query return.\n\n \\param[in,out]    cameraInfo             Array of VmbCameraInfo_t, allocated by the caller.\n                                          The camera list is copied here. May be null.\n\n \\param[in]        listLength             Number of entries in the callers cameraInfo array.\n\n \\param[in,out]    numFound               Number of cameras found. Can be more than listLength.\n\n \\param[in]        sizeofCameraInfo       Size of one VmbCameraInfo_t entry (if \\p cameraInfo is null, this parameter is ignored).\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p numFound is null\n\n \\retval ::VmbErrorStructSize         The given struct size is not valid for this API version and \\p cameraInfo is not null\n\n \\retval ::VmbErrorMoreData           The given list length was insufficient to hold all available entries"]
    pub unsafe fn VmbCamerasList(
        &self,
        cameraInfo: *mut VmbCameraInfo_t,
        listLength: VmbUint32_t,
        numFound: *mut VmbUint32_t,
        sizeofCameraInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCamerasList
            .as_ref()
            .expect("Expected function, got error."))(
            cameraInfo,
            listLength,
            numFound,
            sizeofCameraInfo,
        )
    }
    #[doc = " \\brief Retrieve information about a single camera given its handle.\n\n Note: Some information is only filled for opened cameras.\n\n \\param[in]       cameraHandle            The handle of the camera; both remote and local device handles are permitted\n\n \\param[in,out]   info                    Structure where information will be copied\n\n \\param[in]       sizeofCameraInfo        Size of the structure\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorStructSize         The given struct size is not valid for this API version\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadParameter       \\p info is null\n\n \\retval ::VmbErrorBadHandle          The handle does not correspond to a camera"]
    pub unsafe fn VmbCameraInfoQueryByHandle(
        &self,
        cameraHandle: VmbHandle_t,
        info: *mut VmbCameraInfo_t,
        sizeofCameraInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCameraInfoQueryByHandle
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle, info, sizeofCameraInfo)
    }
    #[doc = " \\brief Retrieve information about a single camera given the ID of the camera.\n\n Note: Some information is only filled for opened cameras.\n\n \\param[in]       idString                ID of the camera\n\n \\param[in,out]   info                    Structure where information will be copied\n\n \\param[in]       sizeofCameraInfo        Size of the structure\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p idString or \\p info are null or \\p idString is the empty string\n\n \\retval ::VmbErrorNotFound           No camera with the given id is found\n\n \\retval ::VmbErrorStructSize         The given struct size is not valid for this API version"]
    pub unsafe fn VmbCameraInfoQuery(
        &self,
        idString: *const ::std::os::raw::c_char,
        info: *mut VmbCameraInfo_t,
        sizeofCameraInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCameraInfoQuery
            .as_ref()
            .expect("Expected function, got error."))(idString, info, sizeofCameraInfo)
    }
    #[doc = " \\brief Open the specified camera.\n\n \\param[in]   idString            ID of the camera.\n \\param[in]   accessMode          The desired access mode.\n \\param[out]  cameraHandle        The remote device handle of the camera, if opened successfully.\n\n A camera may be opened in a specific access mode, which determines\n the level of control you have on a camera.\n Examples for idString:\n\n \"DEV_81237473991\" for an ID given by a transport layer,\n \"169.254.12.13\" for an IP address,\n \"000F314C4BE5\" for a MAC address or\n \"DEV_1234567890\" for an ID as reported by Vmb\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInUse              The camera with the given ID is already opened\n\n \\retval ::VmbErrorInvalidCall        If called from frame callback or chunk access callback\n\n \\retval ::VmbErrorBadParameter       If \\p idString or \\p cameraHandle are null\n\n \\retval ::VmbErrorInvalidAccess      A camera with the given id was found, but could not be opened\n\n \\retval ::VmbErrorNotFound           The designated camera cannot be found"]
    pub unsafe fn VmbCameraOpen(
        &self,
        idString: *const ::std::os::raw::c_char,
        accessMode: VmbAccessMode_t,
        cameraHandle: *mut VmbHandle_t,
    ) -> VmbError_t {
        (self
            .VmbCameraOpen
            .as_ref()
            .expect("Expected function, got error."))(idString, accessMode, cameraHandle)
    }
    #[doc = " \\brief Close the specified camera.\n\n Depending on the access mode this camera was opened with, events are killed,\n callbacks are unregistered, and camera control is released.\n\n \\param[in]   cameraHandle        A valid camera handle\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInUse              The camera is currently in use with ::VmbChunkDataAccess\n\n \\retval ::VmbErrorBadHandle          The handle does not correspond to an open camera\n\n \\retval ::VmbErrorInvalidCall        If called from frame callback or chunk access callback"]
    pub unsafe fn VmbCameraClose(&self, cameraHandle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCameraClose
            .as_ref()
            .expect("Expected function, got error."))(cameraHandle)
    }
    #[doc = " \\brief List all the features for this entity.\n\n This function lists all implemented features, whether they are currently available or not.\n The list of features does not change as long as the entity is connected.\n\n This function is usually called twice: once with an empty list to query the length\n of the list, and then again with a list of the correct length.\n\n If ::VmbErrorMoreData is returned and \\p numFound is non-null, the total number of features has been written to \\p numFound.\n\n If there are more elements in \\p featureInfoList than features available, the remaining elements\n are filled with zero-initialized ::VmbFeatureInfo_t structs.\n\n \\param[in]   handle                  Handle for an entity that exposes features\n \\param[out]  featureInfoList         An array of ::VmbFeatureInfo_t to be filled by the API. May be null if \\p numFund is used for size query.\n \\param[in]   listLength              Number of ::VmbFeatureInfo_t elements provided\n \\param[out]  numFound                Number of ::VmbFeatureInfo_t elements found. May be null if \\p featureInfoList is not null.\n \\param[in]   sizeofFeatureInfo       Size of a ::VmbFeatureInfo_t entry\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorStructSize         The given struct size of ::VmbFeatureInfo_t is not valid for this version of the API\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       Both \\p featureInfoList and \\p numFound are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorMoreData           The given list length was insufficient to hold all available entries"]
    pub unsafe fn VmbFeaturesList(
        &self,
        handle: VmbHandle_t,
        featureInfoList: *mut VmbFeatureInfo_t,
        listLength: VmbUint32_t,
        numFound: *mut VmbUint32_t,
        sizeofFeatureInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeaturesList
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            featureInfoList,
            listLength,
            numFound,
            sizeofFeatureInfo,
        )
    }
    #[doc = " \\brief Query information about the constant properties of a feature.\n\n Users provide a pointer to ::VmbFeatureInfo_t, which is then set to the internal representation.\n\n \\param[in]   handle                  Handle for an entity that exposes features\n \\param[in]   name                    Name of the feature\n \\param[out]  featureInfo             The feature info to query\n \\param[in]   sizeofFeatureInfo       Size of the structure\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorStructSize         The given struct size of ::VmbFeatureInfo_t is not valid for this version of the API\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p featureInfo are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           A feature with the given name does not exist.\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbFeatureInfoQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        featureInfo: *mut VmbFeatureInfo_t,
        sizeofFeatureInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureInfoQuery
            .as_ref()
            .expect("Expected function, got error."))(
            handle, name, featureInfo, sizeofFeatureInfo
        )
    }
    #[doc = " \\brief List all the features selected by a given feature for this module.\n\n This function lists all selected features, whether they are currently available or not.\n Features with selected features (\"selectors\") have no direct impact on the camera,\n but only influence the register address that selected features point to.\n The list of features does not change while the camera/interface is connected.\n This function is usually called twice: once with an empty array to query the length\n of the list, and then again with an array of the correct length.\n\n \\param[in]   handle                  Handle for an entity that exposes features\n \\param[in]   name                    Name of the feature\n \\param[out]  featureInfoList         An array of ::VmbFeatureInfo_t to be filled by the API. May be null if \\p numFound is used for size query.\n \\param[in]   listLength              Number of ::VmbFeatureInfo_t elements provided\n \\param[out]  numFound                Number of ::VmbFeatureInfo_t elements found. May be null if \\p featureInfoList is not null.\n \\param[in]   sizeofFeatureInfo       Size of a ::VmbFeatureInfo_t entry\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorBadParameter       \\p name is null or both \\p featureInfoList and \\p numFound are null\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorStructSize         The given struct size of ::VmbFeatureInfo_t is not valid for this version of the API\n\n \\retval ::VmbErrorMoreData           The given list length was insufficient to hold all available entries"]
    pub unsafe fn VmbFeatureListSelected(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        featureInfoList: *mut VmbFeatureInfo_t,
        listLength: VmbUint32_t,
        numFound: *mut VmbUint32_t,
        sizeofFeatureInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureListSelected
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            name,
            featureInfoList,
            listLength,
            numFound,
            sizeofFeatureInfo,
        )
    }
    #[doc = " \\brief Return the dynamic read and write capabilities of this feature.\n\n The access mode of a feature may change. For example, if \"PacketSize\"\n is locked while image data is streamed, it is only readable.\n\n \\param[in]   handle              Handle for an entity that exposes features.\n \\param[in]   name                Name of the feature.\n \\param[out]  isReadable          Indicates if this feature is readable. May be null.\n \\param[out]  isWriteable         Indicates if this feature is writable. May be null.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name is null or both \\p isReadable and \\p isWriteable are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbFeatureAccessQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        isReadable: *mut VmbBool_t,
        isWriteable: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureAccessQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, isReadable, isWriteable)
    }
    #[doc = " \\brief Get the value of an integer feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[out]  value       Value to get\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p value are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Integer\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureIntGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Set the value of an integer feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[in]   value       Value to set\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorInvalidCall        If called from feature callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       If \\p name is null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Integer\n\n \\retval ::VmbErrorInvalidAccess      The feature is unavailable or not writable\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently\n\n \\retval ::VmbErrorInvalidValue       If value is either out of bounds or not an increment of the minimum\n"]
    pub unsafe fn VmbFeatureIntSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Query the range of an integer feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[out]  min         Minimum value to be returned. May be null.\n \\param[out]  max         Maximum value to be returned. May be null.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       If \\p name is null or both \\p min and \\p max are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature name is not Integer\n\n \\retval ::VmbErrorInvalidAccess      The range information is unavailable or not writable"]
    pub unsafe fn VmbFeatureIntRangeQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        min: *mut VmbInt64_t,
        max: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntRangeQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, min, max)
    }
    #[doc = " \\brief Query the increment of an integer feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[out]  value       Value of the increment to get.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       If \\p name or \\p value are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Integer\n\n \\retval ::VmbErrorInvalidAccess      The information is unavailable or cannot be read"]
    pub unsafe fn VmbFeatureIntIncrementQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntIncrementQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Retrieves info about the valid value set of an integer feature.\n\n Retrieves information about the set of valid values of an integer feature. If null is passed as buffer,\n only the size of the set is determined and written to bufferFilledCount; Otherwise the largest possible\n number of elements of the valid value set is copied to buffer.\n\n \\param[in]   handle                  The handle for the entity the feature information is retrieved from\n \\param[in]   name                    The name of the feature to retrieve the info for; if null is passed ::VmbErrorBadParameter is returned\n \\param[in]   buffer                  The array to copy the valid values to or null if only the size of the set is requested\n \\param[in]   bufferSize              The size of buffer; if buffer is null, the value is ignored\n \\param[out]  setSize                 The total number of elements in the set; the value is set, if ::VmbErrorMoreData is returned\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess                        The call was successful\n\n \\retval ::VmbErrorApiNotStarted                  ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter                   \\p name is null or both \\p buffer and \\p bufferFilledCount are null\n\n \\retval ::VmbErrorBadHandle                      The given handle is not valid\n\n \\retval ::VmbErrorNotFound                       The feature was not found\n\n \\retval ::VmbErrorWrongType                      The type of the feature is not Integer\n\n \\retval ::VmbErrorValidValueSetNotPresent        The feature does not provide a valid value set\n\n \\retval ::VmbErrorMoreData                       Some of data was retrieved successfully, but the size of buffer is insufficient to store all elements\n\n \\retval ::VmbErrorIncomplete                     The module the handle refers to is in a state where it cannot complete the request\n\n \\retval ::VmbErrorOther                          Some other issue occurred"]
    pub unsafe fn VmbFeatureIntValidValueSetQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        buffer: *mut VmbInt64_t,
        bufferSize: VmbUint32_t,
        setSize: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureIntValidValueSetQuery
            .as_ref()
            .expect("Expected function, got error."))(
            handle, name, buffer, bufferSize, setSize
        )
    }
    #[doc = " \\brief Get the value of a float feature.\n\n \\param[in]   handle  Handle for an entity that exposes features\n \\param[in]   name    Name of the feature\n \\param[out]  value   Value to get\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p value are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Float\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureFloatGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *mut f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Set the value of a float feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[in]   value       Value to set\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from feature callback\n\n \\retval ::VmbErrorBadParameter       \\p name is null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Float\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently\n\n \\retval ::VmbErrorInvalidValue       If value is not within valid bounds"]
    pub unsafe fn VmbFeatureFloatSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Query the range of a float feature.\n\n Only one of the values may be queried if the other parameter is set to null,\n but if both parameters are null, an error is returned.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[out]  min         Minimum value to be returned. May be null.\n \\param[out]  max         Maximum value to be returned. May be null.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorBadParameter       \\p name is null or both \\p min and \\p max are null\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Float"]
    pub unsafe fn VmbFeatureFloatRangeQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        min: *mut f64,
        max: *mut f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatRangeQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, min, max)
    }
    #[doc = " \\brief Query the increment of a float feature.\n\n \\param[in]   handle              Handle for an entity that exposes features\n \\param[in]   name                Name of the feature\n \\param[out]  hasIncrement        `true` if this float feature has an increment.\n \\param[out]  value               Value of the increment to get.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorBadParameter       \\p name is null or both \\p value and \\p hasIncrement are null\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Float"]
    pub unsafe fn VmbFeatureFloatIncrementQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        hasIncrement: *mut VmbBool_t,
        value: *mut f64,
    ) -> VmbError_t {
        (self
            .VmbFeatureFloatIncrementQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, hasIncrement, value)
    }
    #[doc = " \\brief Get the value of an enumeration feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[out]  value       The current enumeration value. The returned value is a\n                          reference to the API value\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p value are null\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature featureName is not Enumeration\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature is not available\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbFeatureEnumGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *mut *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Set the value of an enumeration feature.\n\n \\param[in] handle    Handle for an entity that exposes features\n \\param[in] name      Name of the feature\n \\param[in] value     Value to set\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from feature callback\n\n \\retval ::VmbErrorBadParameter       If \\p name or \\p value are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Enumeration\n\n \\retval ::VmbErrorNotAvailable       The feature is not available\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorInvalidValue       \\p value is not a enum entry for the feature or the existing enum entry is currently not available"]
    pub unsafe fn VmbFeatureEnumSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Query the value range of an enumeration feature.\n\n All elements not filled with the names of enum entries by the function are set to null.\n\n \\param[in]   handle          Handle for an entity that exposes features\n \\param[in]   name            Name of the feature\n \\param[out]  nameArray       An array of enumeration value names; may be null if \\p numFound is used for size query\n \\param[in]   arrayLength     Number of elements in the array\n \\param[out]  numFound        Number of elements found; may be null if \\p nameArray is not null\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name is null or both \\p nameArray and \\p numFound are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorNotImplemented     The feature \\p name is not implemented\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Enumeration\n\n \\retval ::VmbErrorMoreData           The given array length was insufficient to hold all available entries"]
    pub unsafe fn VmbFeatureEnumRangeQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        nameArray: *mut *const ::std::os::raw::c_char,
        arrayLength: VmbUint32_t,
        numFound: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumRangeQuery
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            name,
            nameArray,
            arrayLength,
            numFound,
        )
    }
    #[doc = " \\brief Check if a certain value of an enumeration is available.\n\n \\param[in]   handle              Handle for an entity that exposes features\n \\param[in]   name                Name of the feature\n \\param[in]   value               Value to check\n \\param[out]  isAvailable         Indicates if the given enumeration value is available\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name, \\p value or \\p isAvailable are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Enumeration\n\n \\retval ::VmbErrorNotImplemented     The feature \\p name is not implemented\n\n \\retval ::VmbErrorInvalidValue       There is no enum entry with string representation of \\p value for the given enum feature\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n"]
    pub unsafe fn VmbFeatureEnumIsAvailable(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        isAvailable: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumIsAvailable
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value, isAvailable)
    }
    #[doc = " \\brief Get the integer value for a given enumeration string value.\n\n Converts a name of an enum member into an int value (\"Mono12Packed\" to 0x10C0006)\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the feature\n \\param[in]   value       The enumeration value to get the integer value for\n \\param[out]  intVal      The integer value for this enumeration entry\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       If \\p name, \\p value or \\p intVal are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           No feature with the given name was found\n\n \\retval ::VmbErrorNotImplemented     The feature \\p name is not implemented\n\n \\retval ::VmbErrorInvalidValue       \\p value is not the name of a enum entry for the feature\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Enumeration"]
    pub unsafe fn VmbFeatureEnumAsInt(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        intVal: *mut VmbInt64_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumAsInt
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value, intVal)
    }
    #[doc = " \\brief Get the enumeration string value for a given integer value.\n\n Converts an int value to a name of an enum member (e.g. 0x10C0006 to \"Mono12Packed\")\n\n \\param[in]   handle              Handle for an entity that exposes features\n \\param[in]   name                Name of the feature\n \\param[in]   intValue            The numeric value\n \\param[out]  stringValue         The string value for the numeric value\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p stringValue are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           No feature with the given name was found\n\n \\retval ::VmbErrorNotImplemented     No feature \\p name is not implemented\n\n \\retval ::VmbErrorInvalidValue       \\p intValue is not the int value of an enum entry\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Enumeration"]
    pub unsafe fn VmbFeatureEnumAsString(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        intValue: VmbInt64_t,
        stringValue: *mut *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumAsString
            .as_ref()
            .expect("Expected function, got error."))(handle, name, intValue, stringValue)
    }
    #[doc = " \\brief Get infos about an entry of an enumeration feature.\n\n \\param[in]   handle                      Handle for an entity that exposes features\n \\param[in]   featureName                 Name of the feature\n \\param[in]   entryName                   Name of the enum entry of that feature\n \\param[out]  featureEnumEntry            Infos about that entry returned by the API\n \\param[in]   sizeofFeatureEnumEntry      Size of the structure\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorStructSize         Size of ::VmbFeatureEnumEntry_t is not compatible with the API version\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p featureName, \\p entryName or \\p featureEnumEntry are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorNotImplemented     The feature \\p name is not implemented\n\n \\retval ::VmbErrorInvalidValue       There is no enum entry with a string representation of \\p entryName\n\n \\retval ::VmbErrorWrongType          The type of feature featureName is not Enumeration"]
    pub unsafe fn VmbFeatureEnumEntryGet(
        &self,
        handle: VmbHandle_t,
        featureName: *const ::std::os::raw::c_char,
        entryName: *const ::std::os::raw::c_char,
        featureEnumEntry: *mut VmbFeatureEnumEntry_t,
        sizeofFeatureEnumEntry: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureEnumEntryGet
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            featureName,
            entryName,
            featureEnumEntry,
            sizeofFeatureEnumEntry,
        )
    }
    #[doc = " \\brief Get the value of a string feature.\n\n This function is usually called twice: once with an empty buffer to query the length\n of the string, and then again with a buffer of the correct length.\n\n The value written to \\p sizeFilled includes the terminating 0 character of the string.\n\n If a \\p buffer is provided and there its  insufficient to hold all the data, the longest\n possible prefix fitting the buffer is copied to \\p buffer; the last element of \\p buffer is\n set to 0 case.\n\n \\param[in]   handle          Handle for an entity that exposes features\n \\param[in]   name            Name of the string feature\n \\param[out]  buffer          String buffer to fill. May be null if \\p sizeFilled is used for size query.\n \\param[in]   bufferSize      Size of the input buffer\n \\param[out]  sizeFilled      Size actually filled. May be null if \\p buffer is not null.\n\n\n \\return An error code indicating the type of error, if any.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name is null, both \\p buffer and \\p sizeFilled are null or \\p buffer is non-null and bufferSize is 0\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not String\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently\n\n \\retval ::VmbErrorMoreData           The given buffer size was too small"]
    pub unsafe fn VmbFeatureStringGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: VmbUint32_t,
        sizeFilled: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureStringGet
            .as_ref()
            .expect("Expected function, got error."))(
            handle, name, buffer, bufferSize, sizeFilled
        )
    }
    #[doc = " \\brief Set the value of a string feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the string feature\n \\param[in]   value       Value to set\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from feature callback\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p value are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not String\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorInvalidValue       If length of value exceeded the maximum length\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureStringSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureStringSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Get the maximum length of a string feature.\n\n The length reported does not include the terminating 0 char.\n\n Note: For some features the maximum size is not fixed and may change.\n\n \\param[in]   handle          Handle for an entity that exposes features\n \\param[in]   name            Name of the string feature\n \\param[out]  maxLength       Maximum length of this string feature\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p maxLength are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not String\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureStringMaxlengthQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        maxLength: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureStringMaxlengthQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, maxLength)
    }
    #[doc = " \\brief Get the value of a boolean feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the boolean feature\n \\param[out]  value       Value to be read\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p value are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           If feature is not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Boolean\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbFeatureBoolGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureBoolGet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Set the value of a boolean feature.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the boolean feature\n \\param[in]   value       Value to write\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name is null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           If the feature is not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Boolean\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently\n\n \\retval ::VmbErrorInvalidValue       If value is not within valid bounds\n\n \\retval ::VmbErrorInvalidCall        If called from feature callback"]
    pub unsafe fn VmbFeatureBoolSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        value: VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureBoolSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, value)
    }
    #[doc = " \\brief Run a feature command.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the command feature\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorInvalidCall        If called from a feature callback or chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name is null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           Feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Command\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbFeatureCommandRun(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
    ) -> VmbError_t {
        (self
            .VmbFeatureCommandRun
            .as_ref()
            .expect("Expected function, got error."))(handle, name)
    }
    #[doc = " \\brief Check if a feature command is done.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the command feature\n \\param[out]  isDone      State of the command.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadParameter       If \\p name or \\p isDone are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           Feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Command\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureCommandIsDone(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        isDone: *mut VmbBool_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureCommandIsDone
            .as_ref()
            .expect("Expected function, got error."))(handle, name, isDone)
    }
    #[doc = " \\brief Read the memory contents of an area given by a feature name.\n\n This feature type corresponds to a top-level \"Register\" feature in GenICam.\n Data transfer is split up by the transport layer if the feature length is too large.\n You can get the size of the memory area addressed by the feature name by ::VmbFeatureRawLengthQuery().\n\n \\param[in]   handle          Handle for an entity that exposes features\n \\param[in]   name            Name of the raw feature\n \\param[out]  buffer          Buffer to fill\n \\param[in]   bufferSize      Size of the buffer to be filled\n \\param[out]  sizeFilled      Number of bytes actually filled\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p name, \\p buffer or \\p sizeFilled are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           Feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Register\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureRawGet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: VmbUint32_t,
        sizeFilled: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureRawGet
            .as_ref()
            .expect("Expected function, got error."))(
            handle, name, buffer, bufferSize, sizeFilled
        )
    }
    #[doc = " \\brief Write to a memory area given by a feature name.\n\n This feature type corresponds to a first-level \"Register\" node in the XML file.\n Data transfer is split up by the transport layer if the feature length is too large.\n You can get the size of the memory area addressed by the feature name by ::VmbFeatureRawLengthQuery().\n\n \\param[in]   handle          Handle for an entity that exposes features\n \\param[in]   name            Name of the raw feature\n \\param[in]   buffer          Data buffer to use\n \\param[in]   bufferSize      Size of the buffer\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from feature callback or a chunk access callback\n\n \\retval ::VmbErrorBadParameter       \\p name or \\p buffer are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           Feature was not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Register\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureRawSet(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        buffer: *const ::std::os::raw::c_char,
        bufferSize: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureRawSet
            .as_ref()
            .expect("Expected function, got error."))(handle, name, buffer, bufferSize)
    }
    #[doc = " \\brief Get the length of a raw feature for memory transfers.\n\n This feature type corresponds to a first-level \"Register\" node in the XML file.\n\n \\param[in]   handle      Handle for an entity that exposes features\n \\param[in]   name        Name of the raw feature\n \\param[out]  length      Length of the raw feature area (in bytes)\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       If \\p name or \\p length are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           Feature not found\n\n \\retval ::VmbErrorWrongType          The type of feature \\p name is not Register\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorNotImplemented     The feature isn't implemented\n\n \\retval ::VmbErrorNotAvailable       The feature isn't available currently"]
    pub unsafe fn VmbFeatureRawLengthQuery(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        length: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFeatureRawLengthQuery
            .as_ref()
            .expect("Expected function, got error."))(handle, name, length)
    }
    #[doc = " \\brief Register a VmbInvalidationCallback callback for feature invalidation signaling.\n\n Any feature change, either of its value or of its access state, may be tracked\n by registering an invalidation callback.\n Registering multiple callbacks for one feature invalidation event is possible because\n only the combination of handle, name, and callback is used as key. If the same\n combination of handle, name, and callback is registered a second time, the callback remains\n registered and the context is overwritten with \\p userContext.\n\n \\param[in]   handle              Handle for an entity that emits events\n \\param[in]   name                Name of the event\n \\param[in]   callback            Callback to be run when invalidation occurs\n \\param[in]   userContext         User context passed to function\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadParameter       If \\p name or \\p callback are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           No feature with \\p name was found for the module associated with \\p handle\n\n \\retval ::VmbErrorNotImplemented     The feature \\p name is not implemented\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbFeatureInvalidationRegister(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        callback: VmbInvalidationCallback,
        userContext: *mut ::std::os::raw::c_void,
    ) -> VmbError_t {
        (self
            .VmbFeatureInvalidationRegister
            .as_ref()
            .expect("Expected function, got error."))(handle, name, callback, userContext)
    }
    #[doc = " \\brief Unregister a previously registered feature invalidation callback.\n\n Since multiple callbacks may be registered for a feature invalidation event,\n a combination of handle, name, and callback is needed for unregistering, too.\n\n \\param[in] handle          Handle for an entity that emits events\n \\param[in] name            Name of the event\n \\param[in] callback        Callback to be removed\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadParameter       If \\p name or \\p callback are null\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           No feature with \\p name was found for the module associated with \\p handle or there was no listener to unregister\n\n \\retval ::VmbErrorNotImplemented     The feature \\p name is not implemented\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbFeatureInvalidationUnregister(
        &self,
        handle: VmbHandle_t,
        name: *const ::std::os::raw::c_char,
        callback: VmbInvalidationCallback,
    ) -> VmbError_t {
        (self
            .VmbFeatureInvalidationUnregister
            .as_ref()
            .expect("Expected function, got error."))(handle, name, callback)
    }
    #[doc = " \\brief Get the necessary payload size for buffer allocation.\n\n Returns the payload size necessary for buffer allocation as queried from the Camera.\n If the stream module provides a PayloadSize feature, this value will be returned instead.\n If a camera handle is passed, the payload size refers to the stream with index 0.\n\n \\param[in]    handle          Camera or stream handle\n \\param[out]   payloadSize     Payload Size\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess             If no error\n\n \\retval ::VmbErrorApiNotStarted       ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle           The given handle is not valid\n\n \\retval ::VmbErrorBadParameter        \\p payloadSize is null"]
    pub unsafe fn VmbPayloadSizeGet(
        &self,
        handle: VmbHandle_t,
        payloadSize: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbPayloadSizeGet
            .as_ref()
            .expect("Expected function, got error."))(handle, payloadSize)
    }
    #[doc = " \\brief Announce frames to the API that may be queued for frame capturing later.\n\n Allows some preparation for frames like DMA preparation depending on the transport layer.\n The order in which the frames are announced is not taken into consideration by the API.\n If frame.buffer is null, the allocation is done by the transport layer.\n\n \\param[in]   handle          Camera or stream handle\n \\param[in]   frame           Frame buffer to announce\n \\param[in]   sizeofFrame     Size of the frame structure\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorStructSize         The given struct size is not valid for this version of the API\n\n \\retval ::VmbErrorInvalidCall        If called from a frame callback or a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given camera handle is not valid\n\n \\retval ::VmbErrorBadParameter       \\p frame is null\n\n \\retval ::VmbErrorAlready            The frame has already been announced\n\n \\retval ::VmbErrorBusy               The underlying transport layer does not support announcing frames during acquisition\n\n \\retval ::VmbErrorMoreData           The given buffer size is invalid (usually 0)"]
    pub unsafe fn VmbFrameAnnounce(
        &self,
        handle: VmbHandle_t,
        frame: *const VmbFrame_t,
        sizeofFrame: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbFrameAnnounce
            .as_ref()
            .expect("Expected function, got error."))(handle, frame, sizeofFrame)
    }
    #[doc = " \\brief Revoke a frame from the API.\n\n The referenced frame is removed from the pool of frames for capturing images.\n\n \\param[in]   handle      Handle for a camera or stream\n \\param[in]   frame       Frame buffer to be removed from the list of announced frames\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorInvalidCall        If called from a frame callback or a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorBadParameter       The given frame pointer is not valid\n\n \\retval ::VmbErrorBusy               The underlying transport layer does not support revoking frames during acquisition\n\n \\retval ::VmbErrorNotFound           The given frame could not be found for the stream\n\n \\retval ::VmbErrorInUse              The frame is currently still in use (e.g. in a running frame callback)"]
    pub unsafe fn VmbFrameRevoke(
        &self,
        handle: VmbHandle_t,
        frame: *const VmbFrame_t,
    ) -> VmbError_t {
        (self
            .VmbFrameRevoke
            .as_ref()
            .expect("Expected function, got error."))(handle, frame)
    }
    #[doc = " \\brief Revoke all frames assigned to a certain stream or camera.\n\n In case of an failure some of the frames may have been revoked. To prevent this it is recommended to call\n ::VmbCaptureQueueFlush for the same handle before invoking this function.\n\n \\param[in]   handle      Handle for a stream or camera\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorInvalidCall        If called from a frame callback or a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          \\p handle is not valid\n\n \\retval ::VmbErrorInUse              One of the frames of the stream is still in use"]
    pub unsafe fn VmbFrameRevokeAll(&self, handle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbFrameRevokeAll
            .as_ref()
            .expect("Expected function, got error."))(handle)
    }
    #[doc = " \\brief Prepare the API for incoming frames.\n\n \\param[in]   handle      Handle for a camera or a stream\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess                    If no error\n\n \\retval ::VmbErrorInvalidCall                If called from a frame callback or a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted              ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle                  The given handle is not valid; this includes the camera no longer being open\n\n \\retval ::VmbErrorInvalidAccess              Operation is invalid with the current access mode\n\n \\retval ::VmbErrorMoreData                   The buffer size of the announced frames is insufficient\n\n \\retval ::VmbErrorInsufficientBufferCount    The operation requires more buffers to be announced; see the StreamAnnounceBufferMinimum stream feature\n\n \\retval ::VmbErrorAlready                    Capturing was already started"]
    pub unsafe fn VmbCaptureStart(&self, handle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCaptureStart
            .as_ref()
            .expect("Expected function, got error."))(handle)
    }
    #[doc = " \\brief Stop the API from being able to receive frames.\n\n Consequences of VmbCaptureEnd():\n The frame callback will not be called anymore\n\n \\note This function waits for the completion of the last callback for the current capture.\n       If the callback does not return in finite time, this function may not return in finite time either.\n\n \\param[in]   handle      Handle for a stream or camera\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorInvalidCall        If called from a frame callback or a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          \\p handle is not valid"]
    pub unsafe fn VmbCaptureEnd(&self, handle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCaptureEnd
            .as_ref()
            .expect("Expected function, got error."))(handle)
    }
    #[doc = " \\brief Queue frames that may be filled during frame capturing.\n\n The given frame is put into a queue that will be filled sequentially.\n The order in which the frames are filled is determined by the order in which they are queued.\n If the frame was announced with ::VmbFrameAnnounce() before, the application\n has to ensure that the frame is also revoked by calling ::VmbFrameRevoke() or\n ::VmbFrameRevokeAll() when cleaning up.\n\n \\warning \\p callback should to return in finite time. Otherwise ::VmbCaptureEnd and\n          operations resulting in the stream being closed may not return.\n\n \\param[in]   handle              Handle of a camera or stream\n \\param[in]   frame               Pointer to an already announced frame\n \\param[in]   callback            Callback to be run when the frame is complete. Null is OK.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadParameter       If \\p frame is null\n\n \\retval ::VmbErrorBadHandle          No stream related to \\p handle could be found\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInternalFault      The buffer or bufferSize members of \\p frame have been set to null or zero respectively\n\n \\retval ::VmbErrorNotFound           The frame is not a frame announced for the given stream\n\n \\retval ::VmbErrorAlready            The frame is currently queued"]
    pub unsafe fn VmbCaptureFrameQueue(
        &self,
        handle: VmbHandle_t,
        frame: *const VmbFrame_t,
        callback: VmbFrameCallback,
    ) -> VmbError_t {
        (self
            .VmbCaptureFrameQueue
            .as_ref()
            .expect("Expected function, got error."))(handle, frame, callback)
    }
    #[doc = " \\brief Wait for a queued frame to be filled (or dequeued).\n\n The frame needs to be queued and not filled for the function to complete successfully.\n\n If a camera handle is passed, the first stream of the camera is used.\n\n \\param[in]   handle          Handle of a camera or stream\n \\param[in]   frame           Pointer to an already announced and queued frame\n \\param[in]   timeout         Timeout (in milliseconds)\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadParameter       If \\p frame or the buffer of \\p frame are null or the the buffer size of \\p frame is 0\n\n \\retval ::VmbErrorBadHandle          No stream related to \\p handle could be found\n\n \\retval ::VmbErrorNotFound           The frame is not one currently queued for the stream\n\n \\retval ::VmbErrorAlready            The frame has already been dequeued or VmbCaptureFrameWait has been called already for this frame\n\n \\retval ::VmbErrorInUse              If the frame was queued with a frame callback\n\n \\retval ::VmbErrorTimeout            Call timed out\n\n \\retval ::VmbErrorIncomplete         Capture is not active when the function is called"]
    pub unsafe fn VmbCaptureFrameWait(
        &self,
        handle: VmbHandle_t,
        frame: *const VmbFrame_t,
        timeout: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbCaptureFrameWait
            .as_ref()
            .expect("Expected function, got error."))(handle, frame, timeout)
    }
    #[doc = " \\brief Flush the capture queue.\n\n Control of all the currently queued frames will be returned to the user,\n leaving no frames in the capture queue.\n After this call, no frame notification will occur until frames are queued again\n\n Frames need to be revoked separately, if desired.\n\n This function can only succeeds, if no capture is currently active.\n If ::VmbCaptureStart has been called for the stream, but no successful call to ::VmbCaptureEnd\n happened, the function fails with error code ::VmbErrorInUse.\n\n \\param[in]   handle  The handle of the camera or stream to flush.\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadHandle          No stream related to \\p handle could be found.\n\n \\retval ::VmbErrorInUse              There is currently an active capture"]
    pub unsafe fn VmbCaptureQueueFlush(&self, handle: VmbHandle_t) -> VmbError_t {
        (self
            .VmbCaptureQueueFlush
            .as_ref()
            .expect("Expected function, got error."))(handle)
    }
    #[doc = " \\brief List all the transport layers that are used by the API.\n\n Note: This function is usually called twice: once with an empty array to query the length\n       of the list, and then again with an array of the correct length.\n\n \\param[in,out]   transportLayerInfo              Array of VmbTransportLayerInfo_t, allocated by the caller.\n                                                  The transport layer list is copied here. May be null.\n \\param[in]       listLength                      Number of entries in the caller's transportLayerInfo array.\n \\param[in,out]   numFound                        Number of transport layers found. May be more than listLength.\n \\param[in]       sizeofTransportLayerInfo        Size of one ::VmbTransportLayerInfo_t entry (ignored if \\p transportLayerInfo is null).\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInternalFault      An internal fault occurred\n\n \\retval ::VmbErrorNotImplemented     One of the transport layers does not provide the required information\n\n \\retval ::VmbErrorBadParameter       \\p numFound is null\n\n \\retval ::VmbErrorStructSize         The given struct size is not valid for this API version\n\n \\retval ::VmbErrorMoreData           The given list length was insufficient to hold all available entries"]
    pub unsafe fn VmbTransportLayersList(
        &self,
        transportLayerInfo: *mut VmbTransportLayerInfo_t,
        listLength: VmbUint32_t,
        numFound: *mut VmbUint32_t,
        sizeofTransportLayerInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbTransportLayersList
            .as_ref()
            .expect("Expected function, got error."))(
            transportLayerInfo,
            listLength,
            numFound,
            sizeofTransportLayerInfo,
        )
    }
    #[doc = " \\brief List all the interfaces that are currently visible to the API.\n\n Note: All the interfaces known via GenICam transport layers are listed by this\n       command and filled into the provided array. Interfaces may correspond to\n       adapter cards or frame grabber cards.\n       This function is usually called twice: once with an empty array to query the length\n       of the list, and then again with an array of the correct length.\n\n \\param[in,out]   interfaceInfo           Array of ::VmbInterfaceInfo_t, allocated by the caller.\n                                          The interface list is copied here. May be null.\n\n \\param[in]       listLength              Number of entries in the callers interfaceInfo array\n\n \\param[in,out]   numFound                Number of interfaces found. Can be more than listLength\n\n \\param[in]       sizeofInterfaceInfo     Size of one ::VmbInterfaceInfo_t entry\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            The call was successful\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter       \\p numFound is null\n\n \\retval ::VmbErrorStructSize         The given struct size is not valid for this API version\n\n \\retval ::VmbErrorMoreData           The given list length was insufficient to hold all available entries"]
    pub unsafe fn VmbInterfacesList(
        &self,
        interfaceInfo: *mut VmbInterfaceInfo_t,
        listLength: VmbUint32_t,
        numFound: *mut VmbUint32_t,
        sizeofInterfaceInfo: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbInterfacesList
            .as_ref()
            .expect("Expected function, got error."))(
            interfaceInfo,
            listLength,
            numFound,
            sizeofInterfaceInfo,
        )
    }
    #[doc = " \\brief Read an array of bytes.\n\n \\param[in]   handle              Handle for an entity that allows memory access\n \\param[in]   address             Address to be used for this read operation\n \\param[in]   bufferSize          Size of the data buffer to read\n \\param[out]  dataBuffer          Buffer to be filled\n \\param[out]  sizeComplete        Size of the data actually read\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode"]
    pub unsafe fn VmbMemoryRead(
        &self,
        handle: VmbHandle_t,
        address: VmbUint64_t,
        bufferSize: VmbUint32_t,
        dataBuffer: *mut ::std::os::raw::c_char,
        sizeComplete: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbMemoryRead
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            address,
            bufferSize,
            dataBuffer,
            sizeComplete,
        )
    }
    #[doc = " \\brief Write an array of bytes.\n\n \\param[in]   handle              Handle for an entity that allows memory access\n \\param[in]   address             Address to be used for this read operation\n \\param[in]   bufferSize          Size of the data buffer to write\n \\param[in]   dataBuffer          Data to write\n \\param[out]  sizeComplete        Number of bytes successfully written; if an\n                                  error occurs this is less than bufferSize\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorMoreData           Not all data were written; see sizeComplete value for the number of bytes written"]
    pub unsafe fn VmbMemoryWrite(
        &self,
        handle: VmbHandle_t,
        address: VmbUint64_t,
        bufferSize: VmbUint32_t,
        dataBuffer: *const ::std::os::raw::c_char,
        sizeComplete: *mut VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbMemoryWrite
            .as_ref()
            .expect("Expected function, got error."))(
            handle,
            address,
            bufferSize,
            dataBuffer,
            sizeComplete,
        )
    }
    #[doc = " \\brief Write the current features related to a module to a xml file\n\n Camera must be opened beforehand and function needs corresponding handle.\n With given filename parameter path and name of XML file can be determined.\n Additionally behaviour of function can be set with providing 'persistent struct'.\n\n \\param[in]   handle              Handle for an entity that allows register access\n \\param[in]   filePath            The path to the file to save the settings to; relative paths are relative to the current working directory\n \\param[in]   settings            Settings struct; if null the default settings are used\n                                  (persist features except LUT for the remote device, maximum 5 iterations, logging only errors)\n \\param[in]   sizeofSettings      Size of settings struct\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorBadParameter       If \\p filePath is or the settings struct is invalid\n\n \\retval ::VmbErrorStructSize         If sizeofSettings the struct size does not match the size of the struct expected by the API\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorNotFound           The provided handle is insufficient to identify all the modules that should be saved\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorIO                 There was an issue writing the file."]
    pub unsafe fn VmbSettingsSave(
        &self,
        handle: VmbHandle_t,
        filePath: *const VmbFilePathChar_t,
        settings: *const VmbFeaturePersistSettings_t,
        sizeofSettings: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbSettingsSave
            .as_ref()
            .expect("Expected function, got error."))(
            handle, filePath, settings, sizeofSettings
        )
    }
    #[doc = " \\brief Load all feature values from xml file to device-related modules.\n\n The modules must be opened beforehand. If the handle is non-null it must be a valid handle other than the Vmb API handle.\n Additionally behaviour of function can be set with providing \\p settings . Note that even in case of an failure some or all of the features\n may have been set for some of the modules.\n\n The error code ::VmbErrorRetriesExceeded only indicates that the number of retries was insufficient\n to restore the features. Even if the features could not be restored for one of the modules, restoring the features is not aborted but the process\n continues for other modules, if present.\n\n \\param[in]   handle              Handle related to the modules to write the values to;\n                                  may be null to indicate that modules should be identified based on the information provided in the input file\n\n \\param[in]   filePath            The path to the file to load the settings from; relative paths are relative to the current working directory\n \\param[in]   settings            Settings struct; pass null to use the default settings. If the \\p maxIterations field is 0, the number of\n                                  iterations is determined by the value loaded from the xml file\n \\param[in]   sizeofSettings      Size of the settings struct\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess            If no error\n\n \\retval ::VmbErrorApiNotStarted      ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorInvalidCall        If called from a chunk access callback\n\n \\retval ::VmbErrorStructSize         If sizeofSettings the struct size does not match the size of the struct expected by the API\n\n \\retval ::VmbErrorWrongType          \\p handle is neither null nor a transport layer, interface, local device, remote device or stream handle\n\n \\retval ::VmbErrorBadHandle          The given handle is not valid\n\n \\retval ::VmbErrorAmbiguous          The modules to restore the settings for cannot be uniquely identified based on the information available\n\n \\retval ::VmbErrorNotFound           The provided handle is insufficient to identify all the modules that should be restored\n\n \\retval ::VmbErrorRetriesExceeded    Some or all of the features could not be restored with the max iterations specified\n\n \\retval ::VmbErrorInvalidAccess      Operation is invalid with the current access mode\n\n \\retval ::VmbErrorBadParameter       If \\p filePath is null or the settings struct is invalid\n\n \\retval ::VmbErrorIO                 There was an issue with reading the file."]
    pub unsafe fn VmbSettingsLoad(
        &self,
        handle: VmbHandle_t,
        filePath: *const VmbFilePathChar_t,
        settings: *const VmbFeaturePersistSettings_t,
        sizeofSettings: VmbUint32_t,
    ) -> VmbError_t {
        (self
            .VmbSettingsLoad
            .as_ref()
            .expect("Expected function, got error."))(
            handle, filePath, settings, sizeofSettings
        )
    }
    #[doc = " \\brief Access chunk data for a frame.\n\n This function can only succeed if the given frame has been filled by the API.\n\n \\param[in] frame                  A pointer to a filled frame that is announced\n \\param[in] chunkAccessCallback    A callback to access the chunk data from\n \\param[in] userContext            A pointer to pass to the callback\n\n\n \\return An error code indicating success or the type of error that occurred.\n\n \\retval ::VmbErrorSuccess                The call was successful\n\n \\retval ::VmbErrorInvalidCall            If called from a chunk access callback or a feature callback\n\n \\retval ::VmbErrorApiNotStarted          ::VmbStartup() was not called before the current command\n\n \\retval ::VmbErrorBadParameter           \\p frame or \\p chunkAccessCallback are null\n\n \\retval ::VmbErrorInUse                  The frame state does not allow for retrieval of chunk data\n                                          (e.g. the frame could have been reenqueued before the chunk access could happen).\n\n \\retval ::VmbErrorNotFound               The frame is currently not announced for a stream\n\n \\retval ::VmbErrorDeviceNotOpen          If the device the frame was received from is no longer open\n\n \\retval ::VmbErrorNoChunkData            \\p frame does not contain chunk data\n\n \\retval ::VmbErrorParsingChunkData       The chunk data does not adhere to the expected format\n\n \\retval ::VmbErrorUserCallbackException  The callback threw an exception\n\n \\retval ::VmbErrorFeaturesUnavailable    The feature description for the remote device is unavailable\n\n \\retval ::VmbErrorCustom                 The minimum a user defined error code returned by the callback"]
    pub unsafe fn VmbChunkDataAccess(
        &self,
        frame: *const VmbFrame_t,
        chunkAccessCallback: VmbChunkAccessCallback,
        userContext: *mut ::std::os::raw::c_void,
    ) -> VmbError_t {
        (self
            .VmbChunkDataAccess
            .as_ref()
            .expect("Expected function, got error."))(
            frame, chunkAccessCallback, userContext
        )
    }
}
